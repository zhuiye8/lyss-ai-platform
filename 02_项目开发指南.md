# LYSS AI 平台：完整项目开发指南

**版本**: 1.0  
**最后更新**: 2025年7月7日  
**适用对象**: 单人开发者  

---

## 🚀 **项目概述**

本指南将指导您从零开始构建 LYSS AI 平台，这是一个基于供应商作用域设计的智能AI聚合平台。整个项目采用现代化的技术栈，确保高性能、低成本和易维护。

### 📋 **项目特性**

- ✅ **供应商作用域管理**: 优雅的权限控制机制
- ✅ **智能记忆系统**: 基于Mem0的个性化对话
- ✅ **成本优化**: 多层缓存 + 智能记忆压缩
- ✅ **现代化界面**: React + Ant Design X
- ✅ **完全自托管**: 无外部依赖

---

## 📂 **项目结构**

```
lyss-ai-platform/
├── docker-compose.yml          # Docker 编排文件
├── .env                       # 环境变量配置
├── README.md                  # 项目说明
├── backend/                   # 后端服务
│   ├── Dockerfile
│   ├── pyproject.toml         # Poetry 依赖配置
│   ├── poetry.lock
│   ├── app/
│   │   ├── __init__.py
│   │   ├── main.py           # FastAPI 应用入口
│   │   ├── core/             # 核心配置
│   │   │   ├── __init__.py
│   │   │   ├── config.py     # 应用配置
│   │   │   ├── database.py   # 数据库连接
│   │   │   └── security.py   # 安全配置
│   │   ├── models/           # 数据模型
│   │   │   ├── __init__.py
│   │   │   ├── user.py       # 用户模型
│   │   │   ├── provider.py   # 供应商模型
│   │   │   └── conversation.py # 对话模型
│   │   ├── api/              # API 路由
│   │   │   ├── __init__.py
│   │   │   ├── v1/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── auth.py   # 认证相关
│   │   │   │   ├── providers.py # 供应商管理
│   │   │   │   └── chat.py   # 对话相关
│   │   ├── services/         # 业务逻辑
│   │   │   ├── __init__.py
│   │   │   ├── auth_service.py
│   │   │   ├── provider_service.py
│   │   │   ├── memory_service.py
│   │   │   └── chat_service.py
│   │   └── utils/            # 工具函数
│   │       ├── __init__.py
│   │       ├── cache.py
│   │       └── ai_clients.py
├── frontend/                  # 前端应用
│   ├── package.json
│   ├── pnpm-lock.yaml
│   ├── tsconfig.json
│   ├── vite.config.ts
│   ├── src/
│   │   ├── App.tsx
│   │   ├── main.tsx
│   │   ├── components/       # 通用组件
│   │   │   ├── Layout/
│   │   │   ├── ProviderManagement/
│   │   │   └── Chat/
│   │   ├── pages/           # 页面组件
│   │   │   ├── LoginPage.tsx
│   │   │   ├── ChatPage.tsx
│   │   │   └── ProviderPage.tsx
│   │   ├── services/        # API 服务
│   │   │   ├── api.ts
│   │   │   ├── auth.ts
│   │   │   └── providers.ts
│   │   ├── store/           # 状态管理
│   │   │   ├── auth.ts
│   │   │   └── providers.ts
│   │   └── types/           # 类型定义
│   │       ├── user.ts
│   │       ├── provider.ts
│   │       └── chat.ts
└── docs/                     # 文档
    ├── api/                  # API 文档
    ├── deployment/           # 部署文档
    └── development/          # 开发文档
```

---

## 🛠️ **开发环境准备**

### **1. 基础环境**

确保您的开发环境已安装以下工具：

```bash
# 检查 Docker 版本
docker --version
# 应该显示 Docker version 20.10.0 或更高版本

# 检查 Docker Compose 版本
docker-compose --version
# 应该显示 Docker Compose version 2.0.0 或更高版本

# 检查 Node.js 版本
node --version
# 应该显示 v18.0.0 或更高版本

# 检查 Python 版本
python --version
# 应该显示 Python 3.11.0 或更高版本
```

### **2. 安装开发工具**

```bash
# 安装 Poetry (Python 依赖管理)
curl -sSL https://install.python-poetry.org | python3 -

# 安装 pnpm (Node.js 包管理器)
npm install -g pnpm

# 验证安装
poetry --version
pnpm --version
```

---

## 🏗️ **项目初始化**

### **步骤1: 创建项目目录**

```bash
# 创建项目根目录
mkdir lyss-ai-platform
cd lyss-ai-platform

# 创建基础目录结构
mkdir -p backend/app/{core,models,api/v1,services,utils}
mkdir -p frontend/src/{components,pages,services,store,types}
mkdir -p docs/{api,deployment,development}
```

### **步骤2: 配置环境变量**

创建 `.env` 文件：

```bash
# .env 文件内容
# 数据库配置
POSTGRES_USER=lyss_user
POSTGRES_PASSWORD=your_strong_password_here
POSTGRES_DB=lyss_db
POSTGRES_HOST=localhost
POSTGRES_PORT=5432

# Redis 配置
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_DB=0

# Qdrant 配置
QDRANT_HOST=localhost
QDRANT_PORT=6333

# 应用配置
SECRET_KEY=your-secret-key-here-minimum-32-characters
API_V1_STR=/api/v1
PROJECT_NAME=LYSS AI Platform

# 前端配置
VITE_API_URL=http://localhost:8000
VITE_APP_NAME=LYSS AI Platform
```

### **步骤3: Docker 基础设施**

创建 `docker-compose.yml`：

```yaml
version: '3.8'

services:
  # PostgreSQL 数据库
  postgres:
    image: postgres:16-alpine
    container_name: lyss_postgres
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    restart: unless-stopped
    networks:
      - lyss_network

  # Redis 缓存
  redis:
    image: redis:7-alpine
    container_name: lyss_redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped
    networks:
      - lyss_network

  # Qdrant 向量数据库
  qdrant:
    image: qdrant/qdrant:v1.10.1
    container_name: lyss_qdrant
    ports:
      - "6333:6333"
    volumes:
      - qdrant_data:/qdrant/storage
    restart: unless-stopped
    networks:
      - lyss_network

  # 后端服务
  backend:
    build: ./backend
    container_name: lyss_backend
    ports:
      - "8000:8000"
    environment:
      - POSTGRES_HOST=postgres
      - REDIS_HOST=redis
      - QDRANT_HOST=qdrant
    env_file:
      - .env
    depends_on:
      - postgres
      - redis
      - qdrant
    volumes:
      - ./backend:/app
    restart: unless-stopped
    networks:
      - lyss_network

  # 前端服务
  frontend:
    build: ./frontend
    container_name: lyss_frontend
    ports:
      - "3000:3000"
    environment:
      - VITE_API_URL=http://localhost:8000
    depends_on:
      - backend
    volumes:
      - ./frontend:/app
      - /app/node_modules
    restart: unless-stopped
    networks:
      - lyss_network

volumes:
  postgres_data:
  redis_data:
  qdrant_data:

networks:
  lyss_network:
    driver: bridge
```

---

## 🔧 **后端开发**

### **步骤1: 初始化 Poetry 项目**

```bash
cd backend

# 初始化 Poetry 项目
poetry init --name lyss-ai-platform --version 0.1.0 --description "LYSS AI Platform Backend"

# 添加依赖
poetry add fastapi uvicorn[standard] sqlalchemy alembic psycopg2-binary redis mem0ai qdrant-client pydantic-settings python-jose[cryptography] passlib[bcrypt] python-multipart

# 添加开发依赖
poetry add --group dev pytest pytest-asyncio black isort mypy
```

### **步骤2: 创建基础配置**

创建 `backend/app/core/config.py`：

```python
from pydantic_settings import BaseSettings
from typing import Optional

class Settings(BaseSettings):
    """应用配置"""
    
    # 项目信息
    PROJECT_NAME: str = "LYSS AI Platform"
    VERSION: str = "1.0.0"
    API_V1_STR: str = "/api/v1"
    
    # 安全配置
    SECRET_KEY: str
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    
    # 数据库配置
    POSTGRES_USER: str
    POSTGRES_PASSWORD: str
    POSTGRES_HOST: str
    POSTGRES_PORT: int = 5432
    POSTGRES_DB: str
    
    @property
    def database_url(self) -> str:
        return f"postgresql://{self.POSTGRES_USER}:{self.POSTGRES_PASSWORD}@{self.POSTGRES_HOST}:{self.POSTGRES_PORT}/{self.POSTGRES_DB}"
    
    # Redis 配置
    REDIS_HOST: str
    REDIS_PORT: int = 6379
    REDIS_DB: int = 0
    
    @property
    def redis_url(self) -> str:
        return f"redis://{self.REDIS_HOST}:{self.REDIS_PORT}/{self.REDIS_DB}"
    
    # Qdrant 配置
    QDRANT_HOST: str
    QDRANT_PORT: int = 6333
    
    # 跨域配置
    CORS_ORIGINS: list[str] = ["http://localhost:3000"]
    
    class Config:
        env_file = ".env"
        case_sensitive = True

# 全局配置实例
settings = Settings()
```

### **步骤3: 数据库模型**

创建 `backend/app/models/user.py`：

```python
from sqlalchemy import Column, Integer, String, Boolean, DateTime, Enum
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.sql import func
from enum import Enum as PyEnum

Base = declarative_base()

class UserRole(str, PyEnum):
    """用户角色枚举"""
    ADMIN = "admin"
    USER = "user"

class User(Base):
    """用户模型"""
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String(50), unique=True, index=True, nullable=False)
    email = Column(String(100), unique=True, index=True, nullable=False)
    hashed_password = Column(String(255), nullable=False)
    role = Column(Enum(UserRole), default=UserRole.USER, nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
```

创建 `backend/app/models/provider.py`：

```python
from sqlalchemy import Column, Integer, String, Boolean, DateTime, Enum, ForeignKey, Text, JSON
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from enum import Enum as PyEnum

Base = declarative_base()

class ProviderScope(str, PyEnum):
    """供应商作用域枚举"""
    ORGANIZATION = "organization"
    PERSONAL = "personal"

class ProviderType(str, PyEnum):
    """供应商类型枚举"""
    OPENAI = "openai"
    ANTHROPIC = "anthropic"
    OLLAMA = "ollama"
    CUSTOM = "custom"

class ProviderConfig(Base):
    """供应商配置模型"""
    __tablename__ = "provider_configs"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), nullable=False)
    provider_type = Column(Enum(ProviderType), nullable=False)
    scope = Column(Enum(ProviderScope), nullable=False)
    created_by = Column(Integer, ForeignKey("users.id"), nullable=False)
    api_key = Column(String(500), nullable=False)  # 加密存储
    api_base_url = Column(String(200), nullable=True)
    config = Column(JSON, default=dict)  # 供应商特定配置
    is_active = Column(Boolean, default=True, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # 关系
    creator = relationship("User", back_populates="created_providers")

class ProviderDistribution(Base):
    """供应商分发记录"""
    __tablename__ = "provider_distributions"
    
    id = Column(Integer, primary_key=True, index=True)
    provider_id = Column(Integer, ForeignKey("provider_configs.id"), nullable=False)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    distributed_by = Column(Integer, ForeignKey("users.id"), nullable=False)
    distributed_at = Column(DateTime(timezone=True), server_default=func.now())
    is_active = Column(Boolean, default=True, nullable=False)
    
    # 关系
    provider = relationship("ProviderConfig")
    user = relationship("User", foreign_keys=[user_id])
    distributor = relationship("User", foreign_keys=[distributed_by])
```

### **步骤4: 业务服务层**

创建 `backend/app/services/memory_service.py`：

```python
from mem0 import Memory
from typing import List, Dict, Any
import json
import logging

logger = logging.getLogger(__name__)

class MemoryService:
    """智能记忆服务"""
    
    def __init__(self, qdrant_host: str = "localhost", qdrant_port: int = 6333):
        """初始化记忆服务"""
        self.config = {
            "vector_store": {
                "provider": "qdrant",
                "config": {
                    "collection_name": "lyss_memories",
                    "host": qdrant_host,
                    "port": qdrant_port,
                }
            }
        }
        self.memory = Memory(self.config)
    
    async def enhance_conversation(self, user_id: int, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """使用智能记忆增强对话"""
        try:
            # 1. 检索相关记忆
            if not messages:
                return messages
            
            query = messages[-1]["content"]
            relevant_memories = self.memory.search(
                query=query,
                user_id=str(user_id),
                limit=5
            )
            
            # 2. 构建记忆上下文
            memory_context = ""
            if relevant_memories.get("results"):
                memory_context = "相关记忆:\n" + "\n".join([
                    f"- {memory['memory']}" 
                    for memory in relevant_memories["results"]
                ])
            
            # 3. 增强系统提示
            enhanced_messages = messages.copy()
            if memory_context:
                system_message = {
                    "role": "system",
                    "content": f"""你是一个智能AI助手。以下是用户的相关记忆：

{memory_context}

请基于这些记忆提供个性化的回复，但不要直接提及"记忆"这个词。"""
                }
                enhanced_messages.insert(0, system_message)
            
            return enhanced_messages
            
        except Exception as e:
            logger.error(f"增强对话失败: {e}")
            return messages
    
    async def store_conversation(self, user_id: int, messages: List[Dict[str, Any]]):
        """存储对话到记忆中"""
        try:
            if len(messages) < 2:
                return
            
            # 只存储最近的用户消息和AI回复
            conversation_to_store = messages[-2:]
            
            self.memory.add(
                messages=conversation_to_store,
                user_id=str(user_id)
            )
            
            logger.info(f"成功存储用户 {user_id} 的对话记忆")
            
        except Exception as e:
            logger.error(f"存储对话记忆失败: {e}")
    
    async def get_user_memories(self, user_id: int, limit: int = 10) -> List[Dict[str, Any]]:
        """获取用户的记忆列表"""
        try:
            memories = self.memory.get_all(user_id=str(user_id), limit=limit)
            return memories.get("results", [])
        except Exception as e:
            logger.error(f"获取用户记忆失败: {e}")
            return []
    
    async def delete_user_memories(self, user_id: int):
        """删除用户的所有记忆"""
        try:
            self.memory.delete_all(user_id=str(user_id))
            logger.info(f"成功删除用户 {user_id} 的所有记忆")
        except Exception as e:
            logger.error(f"删除用户记忆失败: {e}")
```

### **步骤5: API 路由**

创建 `backend/app/api/v1/chat.py`：

```python
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List, Dict, Any
from pydantic import BaseModel

from app.core.database import get_db
from app.services.chat_service import ChatService
from app.services.auth_service import get_current_user
from app.models.user import User

router = APIRouter()
chat_service = ChatService()

class ChatMessage(BaseModel):
    """聊天消息模型"""
    role: str
    content: str

class ChatRequest(BaseModel):
    """聊天请求模型"""
    provider_id: int
    messages: List[ChatMessage]

class ChatResponse(BaseModel):
    """聊天响应模型"""
    message: ChatMessage
    provider_name: str
    cached: bool = False

@router.post("/chat", response_model=ChatResponse)
async def chat(
    request: ChatRequest,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """处理聊天请求"""
    try:
        # 转换消息格式
        messages = [msg.dict() for msg in request.messages]
        
        # 调用聊天服务
        response = await chat_service.process_chat(
            user_id=current_user.id,
            provider_id=request.provider_id,
            messages=messages,
            db=db
        )
        
        return ChatResponse(
            message=ChatMessage(
                role=response["role"],
                content=response["content"]
            ),
            provider_name=response["provider_name"],
            cached=response.get("cached", False)
        )
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"聊天处理失败: {str(e)}"
        )
```

### **步骤6: 主应用文件**

创建 `backend/app/main.py`：

```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager

from app.core.config import settings
from app.core.database import create_tables
from app.api.v1 import auth, providers, chat

@asynccontextmanager
async def lifespan(app: FastAPI):
    # 启动时创建数据库表
    await create_tables()
    yield
    # 关闭时的清理工作

app = FastAPI(
    title=settings.PROJECT_NAME,
    version=settings.VERSION,
    description="LYSS AI Platform - 智能AI聚合平台",
    lifespan=lifespan
)

# 配置CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.CORS_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 注册路由
app.include_router(auth.router, prefix=f"{settings.API_V1_STR}/auth", tags=["认证"])
app.include_router(providers.router, prefix=f"{settings.API_V1_STR}/providers", tags=["供应商"])
app.include_router(chat.router, prefix=f"{settings.API_V1_STR}/chat", tags=["对话"])

@app.get("/")
async def root():
    return {"message": "LYSS AI Platform API", "version": settings.VERSION}

@app.get("/health")
async def health_check():
    return {"status": "healthy"}
```

### **步骤7: Dockerfile**

创建 `backend/Dockerfile`：

```dockerfile
FROM python:3.11-slim

# 设置工作目录
WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# 安装 Poetry
RUN pip install poetry

# 复制依赖文件
COPY pyproject.toml poetry.lock ./

# 配置 Poetry
RUN poetry config virtualenvs.create false

# 安装依赖
RUN poetry install --no-dev

# 复制应用代码
COPY . .

# 暴露端口
EXPOSE 8000

# 启动命令
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]
```

---

## 🎨 **前端开发**

### **步骤1: 初始化前端项目**

```bash
cd frontend

# 初始化项目
pnpm create vite . --template react-ts

# 安装依赖
pnpm install

# 安装额外依赖
pnpm add antd @ant-design/x zustand @tanstack/react-query axios react-router-dom
pnpm add -D @types/node
```

### **步骤2: 配置 Vite**

创建 `frontend/vite.config.ts`：

```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  server: {
    host: true,
    port: 3000,
  },
})
```

### **步骤3: 类型定义**

创建 `frontend/src/types/provider.ts`：

```typescript
export enum ProviderScope {
  ORGANIZATION = 'organization',
  PERSONAL = 'personal',
}

export enum ProviderType {
  OPENAI = 'openai',
  ANTHROPIC = 'anthropic',
  OLLAMA = 'ollama',
  CUSTOM = 'custom',
}

export interface ProviderConfig {
  id: number;
  name: string;
  provider_type: ProviderType;
  scope: ProviderScope;
  created_by: number;
  api_base_url?: string;
  config: Record<string, any>;
  is_active: boolean;
  created_at: string;
  updated_at: string;
}

export interface CreateProviderRequest {
  name: string;
  provider_type: ProviderType;
  scope: ProviderScope;
  api_key: string;
  api_base_url?: string;
  config?: Record<string, any>;
}
```

### **步骤4: API 服务**

创建 `frontend/src/services/api.ts`：

```typescript
import axios from 'axios';

const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:8000';

export const api = axios.create({
  baseURL: `${API_BASE_URL}/api/v1`,
  timeout: 10000,
});

// 请求拦截器
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('access_token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// 响应拦截器
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // 清除token并跳转到登录页
      localStorage.removeItem('access_token');
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);
```

### **步骤5: 状态管理**

创建 `frontend/src/store/auth.ts`：

```typescript
import { create } from 'zustand';
import { User } from '@/types/user';

interface AuthState {
  user: User | null;
  token: string | null;
  isAuthenticated: boolean;
  setAuth: (user: User, token: string) => void;
  clearAuth: () => void;
}

export const useAuthStore = create<AuthState>((set) => ({
  user: null,
  token: localStorage.getItem('access_token'),
  isAuthenticated: !!localStorage.getItem('access_token'),
  setAuth: (user, token) => {
    localStorage.setItem('access_token', token);
    set({ user, token, isAuthenticated: true });
  },
  clearAuth: () => {
    localStorage.removeItem('access_token');
    set({ user: null, token: null, isAuthenticated: false });
  },
}));
```

### **步骤6: 前端组件**

创建 `frontend/src/components/Chat/ChatInterface.tsx`：

```typescript
import React, { useState, useEffect } from 'react';
import { Card, List, Avatar, Space, Empty, Button, Select, notification } from 'antd';
import { Sender, Bubble, useXChat } from '@ant-design/x';
import { useQuery } from '@tanstack/react-query';
import { ProviderConfig } from '@/types/provider';
import { useAuthStore } from '@/store/auth';
import { api } from '@/services/api';

const { Option } = Select;

interface ChatInterfaceProps {
  onProviderSelect?: (provider: ProviderConfig) => void;
}

export const ChatInterface: React.FC<ChatInterfaceProps> = ({ onProviderSelect }) => {
  const [selectedProvider, setSelectedProvider] = useState<ProviderConfig | null>(null);
  const { user } = useAuthStore();

  // 获取可用供应商
  const { data: providers, isLoading } = useQuery({
    queryKey: ['available-providers'],
    queryFn: async () => {
      const response = await api.get('/providers/available');
      return response.data;
    },
  });

  // 聊天状态管理
  const { messages, setMessages, isLoading: chatLoading } = useXChat();

  // 发送消息
  const handleSendMessage = async (content: string) => {
    if (!selectedProvider) {
      notification.error({
        message: '请选择AI供应商',
        description: '请先选择一个AI供应商再开始对话',
      });
      return;
    }

    const userMessage = {
      id: Date.now().toString(),
      role: 'user' as const,
      content,
    };

    setMessages([...messages, userMessage]);

    try {
      const response = await api.post('/chat/chat', {
        provider_id: selectedProvider.id,
        messages: [...messages, userMessage],
      });

      const aiMessage = {
        id: (Date.now() + 1).toString(),
        role: 'assistant' as const,
        content: response.data.message.content,
      };

      setMessages([...messages, userMessage, aiMessage]);
    } catch (error) {
      notification.error({
        message: '对话失败',
        description: '请稍后重试',
      });
    }
  };

  return (
    <div style={{ display: 'flex', height: '100vh' }}>
      {/* 侧边栏：供应商选择 */}
      <div style={{ width: 300, borderRight: '1px solid #f0f0f0' }}>
        <Card title="选择AI供应商" size="small">
          {isLoading ? (
            <div>加载中...</div>
          ) : (
            <List
              dataSource={providers}
              renderItem={(provider: ProviderConfig) => (
                <List.Item
                  onClick={() => {
                    setSelectedProvider(provider);
                    onProviderSelect?.(provider);
                  }}
                  className={selectedProvider?.id === provider.id ? 'selected' : ''}
                  style={{ 
                    cursor: 'pointer',
                    backgroundColor: selectedProvider?.id === provider.id ? '#f0f0f0' : 'transparent'
                  }}
                >
                  <Space>
                    <Avatar 
                      size="small" 
                      style={{ 
                        backgroundColor: provider.scope === 'organization' ? '#52c41a' : '#fa8c16' 
                      }}
                    >
                      {provider.name[0]}
                    </Avatar>
                    <div>
                      <div>{provider.name}</div>
                      <div style={{ fontSize: 12, color: '#666' }}>
                        {provider.scope === 'organization' ? '组织' : '个人'}
                      </div>
                    </div>
                  </Space>
                </List.Item>
              )}
            />
          )}
        </Card>
      </div>

      {/* 主聊天区域 */}
      <div style={{ flex: 1 }}>
        {selectedProvider ? (
          <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
            {/* 聊天消息区域 */}
            <div style={{ flex: 1, overflow: 'auto', padding: '16px' }}>
              {messages.map((msg) => (
                <Bubble
                  key={msg.id}
                  content={msg.content}
                  placement={msg.role === 'user' ? 'right' : 'left'}
                  style={{ margin: '8px 0' }}
                />
              ))}
            </div>

            {/* 输入区域 */}
            <div style={{ borderTop: '1px solid #f0f0f0', padding: '16px' }}>
              <Sender
                placeholder={`与 ${selectedProvider.name} 对话...`}
                onSend={handleSendMessage}
                loading={chatLoading}
              />
            </div>
          </div>
        ) : (
          <div style={{ 
            height: '100%', 
            display: 'flex', 
            alignItems: 'center', 
            justifyContent: 'center' 
          }}>
            <Empty description="请选择一个AI供应商开始对话" />
          </div>
        )}
      </div>
    </div>
  );
};
```

### **步骤7: 前端 Dockerfile**

创建 `frontend/Dockerfile`：

```dockerfile
FROM node:18-alpine

# 设置工作目录
WORKDIR /app

# 安装 pnpm
RUN npm install -g pnpm

# 复制依赖文件
COPY package.json pnpm-lock.yaml ./

# 安装依赖
RUN pnpm install

# 复制应用代码
COPY . .

# 暴露端口
EXPOSE 3000

# 启动命令
CMD ["pnpm", "dev", "--host"]
```

---

## 🚀 **部署和运行**

### **步骤1: 启动开发环境**

```bash
# 在项目根目录
cd lyss-ai-platform

# 启动所有服务
docker-compose up -d

# 查看服务状态
docker-compose ps

# 查看日志
docker-compose logs -f backend
docker-compose logs -f frontend
```

### **步骤2: 数据库初始化**

```bash
# 进入后端容器
docker-compose exec backend bash

# 创建数据库迁移
alembic init alembic
alembic revision --autogenerate -m "Initial migration"
alembic upgrade head

# 创建管理员用户
python -c "
from app.core.database import SessionLocal
from app.models.user import User, UserRole
from app.core.security import get_password_hash

db = SessionLocal()
admin_user = User(
    username='admin',
    email='admin@example.com',
    hashed_password=get_password_hash('admin123'),
    role=UserRole.ADMIN
)
db.add(admin_user)
db.commit()
print('管理员用户创建成功')
"
```

### **步骤3: 访问应用**

- **前端界面**: http://localhost:3000
- **后端API**: http://localhost:8000
- **API文档**: http://localhost:8000/docs

### **步骤4: 功能测试**

1. **登录系统**: 使用创建的管理员账号登录
2. **创建供应商**: 添加OpenAI、Anthropic等供应商配置
3. **测试对话**: 选择供应商开始对话，验证智能记忆功能
4. **权限测试**: 创建普通用户，测试权限控制

---

## 📝 **后续开发计划**

### **第一阶段: 基础功能完善**
- ✅ 用户认证和授权
- ✅ 供应商配置管理
- ✅ 基础对话功能
- ✅ 智能记忆集成

### **第二阶段: 高级功能**
- 🔄 对话历史管理
- 🔄 文件上传和处理
- 🔄 插件系统
- 🔄 使用统计和监控

### **第三阶段: 企业级功能**
- 📋 高级RBAC
- 📋 审计日志
- 📋 数据备份
- 📋 性能优化

---

## 🔧 **常见问题解决**

### **Docker 相关问题**

```bash
# 重新构建镜像
docker-compose build --no-cache

# 清理所有容器和网络
docker-compose down -v
docker system prune -a

# 查看容器日志
docker-compose logs [service_name]
```

### **数据库问题**

```bash
# 重置数据库
docker-compose exec postgres psql -U lyss_user -d lyss_db -c "DROP SCHEMA public CASCADE; CREATE SCHEMA public;"

# 重新运行迁移
docker-compose exec backend alembic upgrade head
```

### **前端问题**

```bash
# 清理 node_modules
docker-compose exec frontend rm -rf node_modules
docker-compose exec frontend pnpm install

# 重新启动前端服务
docker-compose restart frontend
```

---

恭喜！您已经完成了 LYSS AI 平台的完整开发指南。这个指南提供了从项目初始化到部署上线的完整流程，让您能够快速构建一个功能完善的AI聚合平台。

记住，开发是一个迭代的过程，建议您先实现基础功能，然后根据实际需求逐步添加更多功能。祝您开发愉快！