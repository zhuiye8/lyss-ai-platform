# LYSS AI å¹³å°ï¼šæ•´åˆæ¶æ„è®¾è®¡æ–¹æ¡ˆ V3

**ç‰ˆæœ¬**: 3.0  
**æœ€åæ›´æ–°**: 2025å¹´7æœˆ7æ—¥  
**ä½œè€…**: æ¶æ„å¸ˆ + AI åŠ©æ‰‹  

---

## ğŸ¯ **æ•´åˆåçš„æ¶æ„è®¾è®¡**

åŸºäºä¾›åº”å•†ä½œç”¨åŸŸï¼ˆProvider Scopeï¼‰çš„æ ¸å¿ƒç†å¿µï¼Œæˆ‘ä»¬è®¾è®¡äº†ä¸€ä¸ª**ç®€åŒ–è€Œå¼ºå¤§**çš„ä¸‰å±‚æ¶æ„ï¼Œæ—¢ä¿æŒäº†æˆæœ¬ä¼˜åŒ–çš„æ ¸å¿ƒç›®æ ‡ï¼Œåˆå……åˆ†åˆ©ç”¨äº†ä½œç”¨åŸŸç®¡ç†çš„ç²¾å¦™è®¾è®¡ã€‚

### ğŸ“ **ç®€åŒ–ä¸‰å±‚æ¶æ„**

```mermaid
graph TD
    subgraph "ç”¨æˆ·äº¤äº’å±‚"
        A[React + Ant Design X] --> B[å¯¹è¯ç»„ä»¶]
        A --> C[ä¾›åº”å•†ç®¡ç†ç•Œé¢]
        A --> D[ç”¨æˆ·ç®¡ç†ç•Œé¢]
    end
    
    subgraph "ä¸šåŠ¡é€»è¾‘å±‚"
        E[FastAPI ä¸»æœåŠ¡] --> F[ä¾›åº”å•†ä½œç”¨åŸŸç®¡ç†]
        E --> G[æ™ºèƒ½è®°å¿† Mem0]
        E --> H[è®¤è¯ä¸æˆæƒ]
        E --> I[AIå¯¹è¯è·¯ç”±]
    end
    
    subgraph "æ•°æ®å­˜å‚¨å±‚"
        J[(PostgreSQL)] --> K[ç”¨æˆ·æ•°æ®]
        J --> L[ä¾›åº”å•†é…ç½®]
        J --> M[å¯¹è¯å†å²]
        N[(Redis)] --> O[ä¼šè¯ç¼“å­˜]
        N --> P[APIå“åº”ç¼“å­˜]
        Q[(Qdrant)] --> R[æ™ºèƒ½è®°å¿†å‘é‡]
    end
    
    A --> E
    E --> J
    E --> N
    G --> Q
    I --> S[å¤–éƒ¨AIä¾›åº”å•†]
```

### ğŸ—ï¸ **ä¾›åº”å•†ä½œç”¨åŸŸåœ¨æ¶æ„ä¸­çš„ä½“ç°**

#### **1. æ•°æ®æ¨¡å‹è®¾è®¡**

```python
# ä¾›åº”å•†é…ç½®æ¨¡å‹
class ProviderConfig(BaseModel):
    id: int
    name: str  # ä¾›åº”å•†åç§°ï¼Œå¦‚ "OpenAI-GPT4"
    provider_type: str  # ä¾›åº”å•†ç±»å‹ï¼šopenai, anthropic, ollama
    scope: ProviderScope  # æ ¸å¿ƒï¼šORGANIZATION æˆ– PERSONAL
    created_by: int  # åˆ›å»ºè€…ç”¨æˆ·ID
    api_key: str  # åŠ å¯†å­˜å‚¨çš„APIå¯†é’¥
    config: dict  # ä¾›åº”å•†ç‰¹å®šé…ç½®
    is_active: bool = True
    created_at: datetime
    updated_at: datetime

# ä¾›åº”å•†ä½œç”¨åŸŸæšä¸¾
class ProviderScope(str, Enum):
    ORGANIZATION = "organization"  # ç»„ç»‡çº§ä¾›åº”å•†
    PERSONAL = "personal"  # ä¸ªäººçº§ä¾›åº”å•†

# ä¾›åº”å•†åˆ†å‘è®°å½•
class ProviderDistribution(BaseModel):
    id: int
    provider_id: int  # åªèƒ½æ˜¯ scope=ORGANIZATION çš„ä¾›åº”å•†
    user_id: int  # è¢«åˆ†å‘ç»™çš„ç”¨æˆ·
    distributed_by: int  # åˆ†å‘è€…ï¼ˆç®¡ç†å‘˜ï¼‰
    distributed_at: datetime
    is_active: bool = True
```

#### **2. æƒé™æ§åˆ¶é€»è¾‘**

```python
class ProviderPermission:
    """ä¾›åº”å•†æƒé™æ§åˆ¶æ ¸å¿ƒé€»è¾‘"""
    
    @staticmethod
    def can_create_provider(user: User, scope: ProviderScope) -> bool:
        """æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å¯ä»¥åˆ›å»ºæŒ‡å®šä½œç”¨åŸŸçš„ä¾›åº”å•†"""
        if scope == ProviderScope.ORGANIZATION:
            return user.role == UserRole.ADMIN
        elif scope == ProviderScope.PERSONAL:
            return True  # ä»»ä½•å·²ç™»å½•ç”¨æˆ·éƒ½å¯ä»¥åˆ›å»ºä¸ªäººä¾›åº”å•†
        return False
    
    @staticmethod
    def can_view_provider(user: User, provider: ProviderConfig) -> bool:
        """æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å¯ä»¥æŸ¥çœ‹ä¾›åº”å•†"""
        if provider.scope == ProviderScope.PERSONAL:
            return provider.created_by == user.id
        elif provider.scope == ProviderScope.ORGANIZATION:
            # ç»„ç»‡ä¾›åº”å•†ï¼šç®¡ç†å‘˜å¯è§ï¼Œæˆ–è€…å·²åˆ†å‘ç»™ç”¨æˆ·
            return (user.role == UserRole.ADMIN or 
                   ProviderDistribution.is_distributed_to_user(provider.id, user.id))
        return False
    
    @staticmethod
    def can_distribute_provider(user: User, provider: ProviderConfig) -> bool:
        """æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å¯ä»¥åˆ†å‘ä¾›åº”å•†"""
        return (user.role == UserRole.ADMIN and 
                provider.scope == ProviderScope.ORGANIZATION)
```

### ğŸ§  **æ™ºèƒ½è®°å¿†é›†æˆ**

```python
class IntelligentMemoryService:
    """æ™ºèƒ½è®°å¿†æœåŠ¡ï¼Œé›†æˆMem0å®ç°ä¸ªæ€§åŒ–å¯¹è¯"""
    
    def __init__(self):
        self.mem0 = Memory({
            "vector_store": {
                "provider": "qdrant",
                "config": {
                    "collection_name": "lyss_memories",
                    "host": "localhost",
                    "port": 6333,
                }
            }
        })
    
    async def enhance_conversation(self, user_id: int, messages: List[dict]) -> List[dict]:
        """ä½¿ç”¨æ™ºèƒ½è®°å¿†å¢å¼ºå¯¹è¯"""
        # 1. æ£€ç´¢ç›¸å…³è®°å¿†
        query = messages[-1]["content"]
        relevant_memories = self.mem0.search(
            query=query, 
            user_id=str(user_id),
            limit=5
        )
        
        # 2. æ„å»ºè®°å¿†ä¸Šä¸‹æ–‡
        memory_context = ""
        if relevant_memories.get("results"):
            memory_context = "ç›¸å…³è®°å¿†:\n" + "\n".join([
                f"- {memory['memory']}" 
                for memory in relevant_memories["results"]
            ])
        
        # 3. å¢å¼ºç³»ç»Ÿæç¤º
        enhanced_messages = messages.copy()
        if memory_context:
            system_message = {
                "role": "system",
                "content": f"""ä½ æ˜¯ä¸€ä¸ªæ™ºèƒ½AIåŠ©æ‰‹ã€‚ä»¥ä¸‹æ˜¯ç”¨æˆ·çš„ç›¸å…³è®°å¿†ï¼š
{memory_context}

è¯·åŸºäºè¿™äº›è®°å¿†æä¾›ä¸ªæ€§åŒ–çš„å›å¤ã€‚"""
            }
            enhanced_messages.insert(0, system_message)
        
        return enhanced_messages
    
    async def store_conversation(self, user_id: int, messages: List[dict]):
        """å­˜å‚¨å¯¹è¯åˆ°è®°å¿†ä¸­"""
        try:
            # åªå­˜å‚¨æœ€è¿‘çš„ç”¨æˆ·æ¶ˆæ¯å’ŒAIå›å¤
            self.mem0.add(
                messages=messages[-2:],  # æœ€åä¸¤æ¡æ¶ˆæ¯
                user_id=str(user_id)
            )
        except Exception as e:
            logger.error(f"å­˜å‚¨å¯¹è¯è®°å¿†å¤±è´¥: {e}")
```

### ğŸ”„ **å¯¹è¯æµç¨‹è®¾è®¡**

```python
class ConversationService:
    """å¯¹è¯æœåŠ¡ï¼Œæ•´åˆä¾›åº”å•†ç®¡ç†å’Œæ™ºèƒ½è®°å¿†"""
    
    async def process_chat(self, user_id: int, provider_id: int, 
                          messages: List[dict]) -> dict:
        """å¤„ç†å¯¹è¯è¯·æ±‚"""
        # 1. éªŒè¯ä¾›åº”å•†æƒé™
        provider = await self.get_provider_by_id(provider_id)
        if not ProviderPermission.can_view_provider(user, provider):
            raise PermissionError("æ— æƒè®¿é—®æ­¤ä¾›åº”å•†")
        
        # 2. ä½¿ç”¨æ™ºèƒ½è®°å¿†å¢å¼ºå¯¹è¯
        enhanced_messages = await self.memory_service.enhance_conversation(
            user_id, messages
        )
        
        # 3. æ£€æŸ¥ç¼“å­˜
        cache_key = self.generate_cache_key(provider_id, enhanced_messages)
        cached_response = await self.redis.get(cache_key)
        if cached_response:
            return json.loads(cached_response)
        
        # 4. è°ƒç”¨AIä¾›åº”å•†
        response = await self.call_ai_provider(provider, enhanced_messages)
        
        # 5. ç¼“å­˜å“åº”
        await self.redis.setex(
            cache_key, 
            expire=3600,  # 1å°æ—¶ç¼“å­˜
            value=json.dumps(response)
        )
        
        # 6. å­˜å‚¨å¯¹è¯è®°å¿†
        conversation_with_response = enhanced_messages + [response["choices"][0]["message"]]
        await self.memory_service.store_conversation(user_id, conversation_with_response)
        
        return response
```

### ğŸ¨ **å‰ç«¯ç»„ä»¶è®¾è®¡**

#### **ä¾›åº”å•†ç®¡ç†ç•Œé¢**

```tsx
// ä¾›åº”å•†ç®¡ç†ç»„ä»¶
const ProviderManagement: React.FC = () => {
  const [providers, setProviders] = useState<ProviderConfig[]>([]);
  const [currentUser] = useCurrentUser();
  
  // æ ¹æ®ç”¨æˆ·è§’è‰²ç­›é€‰å¯è§ä¾›åº”å•†
  const visibleProviders = useMemo(() => {
    return providers.filter(provider => {
      if (provider.scope === 'personal') {
        return provider.created_by === currentUser.id;
      } else {
        // ç»„ç»‡ä¾›åº”å•†ï¼šç®¡ç†å‘˜å¯è§æ‰€æœ‰ï¼Œæ™®é€šç”¨æˆ·åªèƒ½çœ‹åˆ°åˆ†å‘ç»™è‡ªå·±çš„
        return currentUser.role === 'admin' || 
               isProviderDistributedToUser(provider.id, currentUser.id);
      }
    });
  }, [providers, currentUser]);
  
  return (
    <div>
      <Card title="ä¾›åº”å•†ç®¡ç†">
        <Space direction="vertical" style={{ width: '100%' }}>
          {/* åˆ›å»ºä¾›åº”å•†æŒ‰é’® */}
          <Button 
            type="primary" 
            onClick={() => setCreateModalVisible(true)}
            icon={<PlusOutlined />}
          >
            åˆ›å»ºä¾›åº”å•†
          </Button>
          
          {/* ä¾›åº”å•†åˆ—è¡¨ */}
          <Table
            dataSource={visibleProviders}
            columns={[
              {
                title: 'åç§°',
                dataIndex: 'name',
                key: 'name',
              },
              {
                title: 'ç±»å‹',
                dataIndex: 'provider_type',
                key: 'provider_type',
                render: (type) => <Tag color="blue">{type}</Tag>
              },
              {
                title: 'ä½œç”¨åŸŸ',
                dataIndex: 'scope',
                key: 'scope',
                render: (scope) => (
                  <Tag color={scope === 'organization' ? 'green' : 'orange'}>
                    {scope === 'organization' ? 'ç»„ç»‡' : 'ä¸ªäºº'}
                  </Tag>
                )
              },
              {
                title: 'çŠ¶æ€',
                dataIndex: 'is_active',
                key: 'is_active',
                render: (active) => (
                  <Tag color={active ? 'green' : 'red'}>
                    {active ? 'æ¿€æ´»' : 'ç¦ç”¨'}
                  </Tag>
                )
              },
              {
                title: 'æ“ä½œ',
                key: 'actions',
                render: (_, record) => (
                  <Space>
                    <Button size="small" onClick={() => editProvider(record)}>
                      ç¼–è¾‘
                    </Button>
                    {/* åªæœ‰ç»„ç»‡ä¾›åº”å•†ä¸”ç”¨æˆ·æ˜¯ç®¡ç†å‘˜æ—¶æ‰æ˜¾ç¤ºåˆ†å‘æŒ‰é’® */}
                    {record.scope === 'organization' && currentUser.role === 'admin' && (
                      <Button 
                        size="small" 
                        onClick={() => distributeProvider(record)}
                      >
                        åˆ†å‘
                      </Button>
                    )}
                  </Space>
                )
              }
            ]}
          />
        </Space>
      </Card>
    </div>
  );
};
```

#### **æ™ºèƒ½å¯¹è¯ç•Œé¢**

```tsx
// æ™ºèƒ½å¯¹è¯ç»„ä»¶
const IntelligentChat: React.FC = () => {
  const [messages, setMessages] = useState<Message[]>([]);
  const [selectedProvider, setSelectedProvider] = useState<ProviderConfig | null>(null);
  const [availableProviders] = useAvailableProviders(); // è·å–ç”¨æˆ·å¯ç”¨çš„ä¾›åº”å•†
  
  const handleSendMessage = async (content: string) => {
    const userMessage = { role: 'user', content, id: Date.now() };
    setMessages(prev => [...prev, userMessage]);
    
    try {
      // è°ƒç”¨åç«¯APIï¼Œè‡ªåŠ¨åŒ…å«æ™ºèƒ½è®°å¿†å¤„ç†
      const response = await chatAPI.sendMessage({
        provider_id: selectedProvider?.id,
        messages: [...messages, userMessage]
      });
      
      const aiMessage = {
        role: 'assistant',
        content: response.choices[0].message.content,
        id: Date.now() + 1
      };
      
      setMessages(prev => [...prev, aiMessage]);
    } catch (error) {
      notification.error({
        message: 'å¯¹è¯å¤±è´¥',
        description: error.message
      });
    }
  };
  
  return (
    <div style={{ height: '100vh', display: 'flex' }}>
      {/* ä¾§è¾¹æ ï¼šä¾›åº”å•†é€‰æ‹© */}
      <div style={{ width: 300, borderRight: '1px solid #f0f0f0' }}>
        <Card title="é€‰æ‹©AIä¾›åº”å•†" size="small">
          <List
            dataSource={availableProviders}
            renderItem={provider => (
              <List.Item
                onClick={() => setSelectedProvider(provider)}
                className={selectedProvider?.id === provider.id ? 'selected' : ''}
                style={{ cursor: 'pointer' }}
              >
                <Space>
                  <Avatar 
                    size="small" 
                    style={{ backgroundColor: provider.scope === 'organization' ? '#52c41a' : '#fa8c16' }}
                  >
                    {provider.name[0]}
                  </Avatar>
                  <div>
                    <div>{provider.name}</div>
                    <div style={{ fontSize: 12, color: '#666' }}>
                      {provider.scope === 'organization' ? 'ç»„ç»‡' : 'ä¸ªäºº'}
                    </div>
                  </div>
                </Space>
              </List.Item>
            )}
          />
        </Card>
      </div>
      
      {/* ä¸»èŠå¤©åŒºåŸŸ */}
      <div style={{ flex: 1 }}>
        {selectedProvider ? (
          <XChat
            messages={messages}
            onSend={handleSendMessage}
            placeholder={`ä¸ ${selectedProvider.name} å¯¹è¯...`}
          />
        ) : (
          <div style={{ 
            height: '100%', 
            display: 'flex', 
            alignItems: 'center', 
            justifyContent: 'center' 
          }}>
            <Empty description="è¯·é€‰æ‹©ä¸€ä¸ªAIä¾›åº”å•†å¼€å§‹å¯¹è¯" />
          </div>
        )}
      </div>
    </div>
  );
};
```

### ğŸ”§ **æ ¸å¿ƒä¼˜åŠ¿**

1. **ä¾›åº”å•†ä½œç”¨åŸŸç®¡ç†**: é€šè¿‡ç®€å•çš„ä½œç”¨åŸŸæ¦‚å¿µï¼Œä¼˜é›…åœ°è§£å†³äº†å¤æ‚çš„æƒé™ç®¡ç†é—®é¢˜
2. **æ™ºèƒ½è®°å¿†ä¼˜åŒ–**: é›†æˆMem0å®ç°ä¸ªæ€§åŒ–å¯¹è¯ï¼Œå¤§å¹…å‡å°‘tokenæ¶ˆè€—
3. **çµæ´»çš„ç¼“å­˜ç­–ç•¥**: å¤šå±‚ç¼“å­˜æœºåˆ¶ï¼Œè¿›ä¸€æ­¥é™ä½APIè°ƒç”¨æˆæœ¬
4. **ç®€åŒ–çš„æ¶æ„**: ä¸‰å±‚æ¶æ„æ˜“äºç†è§£å’Œç»´æŠ¤ï¼Œé€‚åˆå•äººå¼€å‘
5. **æ¸è¿›å¼æ‰©å±•**: å¯ä»¥é€æ­¥æ·»åŠ æ›´å¤šåŠŸèƒ½ï¼Œæ— éœ€é‡æ„æ ¸å¿ƒæ¶æ„

### ğŸ¯ **ä¸åŸæ–¹æ¡ˆçš„å¯¹æ¯”**

| æ–¹é¢ | åŸå››å±‚æ¶æ„ | æ•´åˆä¸‰å±‚æ¶æ„ |
|------|------------|-------------|
| **å¤æ‚åº¦** | é«˜ï¼ˆå››å±‚æœåŠ¡åè°ƒï¼‰ | ä¸­ï¼ˆä¸‰å±‚æ¸…æ™°åˆ†ç¦»ï¼‰ |
| **ç»´æŠ¤æˆæœ¬** | é«˜ï¼ˆå¤šæœåŠ¡ä¾èµ–ï¼‰ | ä½ï¼ˆé›†ä¸­å¼ç®¡ç†ï¼‰ |
| **æƒé™ç®¡ç†** | å¤æ‚ï¼ˆå¤šå±‚æƒé™ï¼‰ | ç®€å•ï¼ˆä½œç”¨åŸŸæ§åˆ¶ï¼‰ |
| **æˆæœ¬ä¼˜åŒ–** | ä¾èµ–å¤–éƒ¨æœåŠ¡ | å†…ç½®ä¼˜åŒ–ç­–ç•¥ |
| **æ‰©å±•æ€§** | å¥½ | å¥½ |
| **éƒ¨ç½²å¤æ‚åº¦** | é«˜ | ä¸­ |

è¿™ä¸ªæ•´åˆæ–¹æ¡ˆæ—¢ä¿æŒäº†åŸæœ‰çš„æ ¸å¿ƒä¼˜åŠ¿ï¼Œåˆé€šè¿‡ä¾›åº”å•†ä½œç”¨åŸŸçš„ç²¾å¦™è®¾è®¡ï¼Œå®ç°äº†æ›´åŠ æ¸…æ™°å’Œå¯ç»´æŠ¤çš„æ¶æ„ã€‚