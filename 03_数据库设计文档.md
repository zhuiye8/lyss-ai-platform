# LYSS AI å¹³å°ï¼šæ•°æ®åº“è®¾è®¡æ–‡æ¡£

**ç‰ˆæœ¬**: 1.0  
**æœ€åæ›´æ–°**: 2025å¹´7æœˆ7æ—¥  
**æ•°æ®åº“ç±»å‹**: PostgreSQL 16  

---

## ğŸ“‹ **æ•°æ®åº“æ¦‚è§ˆ**

æœ¬æ–‡æ¡£è¯¦ç»†æè¿°äº† LYSS AI å¹³å°çš„æ•°æ®åº“è®¾è®¡ï¼ŒåŸºäºä¾›åº”å•†ä½œç”¨åŸŸï¼ˆProvider Scopeï¼‰æ¶æ„ï¼Œé‡‡ç”¨ PostgreSQL ä½œä¸ºä¸»æ•°æ®åº“ï¼ŒRedis ä½œä¸ºç¼“å­˜å±‚ï¼ŒQdrant ä½œä¸ºå‘é‡æ•°æ®åº“ã€‚

### ğŸ¯ **è®¾è®¡åŸåˆ™**

1. **æ•°æ®ä¸€è‡´æ€§**: ä¸¥æ ¼çš„å¤–é”®çº¦æŸå’Œäº‹åŠ¡å¤„ç†
2. **æ€§èƒ½ä¼˜åŒ–**: åˆç†çš„ç´¢å¼•è®¾è®¡å’ŒæŸ¥è¯¢ä¼˜åŒ–
3. **å®‰å…¨æ€§**: æ•æ„Ÿæ•°æ®åŠ å¯†å­˜å‚¨
4. **å¯æ‰©å±•æ€§**: æ”¯æŒæ°´å¹³æ‰©å±•å’Œåˆ†åŒº
5. **å®¡è®¡è·Ÿè¸ª**: å®Œæ•´çš„æ“ä½œæ—¥å¿—è®°å½•

---

## ğŸ—ï¸ **æ•°æ®åº“æ¶æ„å›¾**

```mermaid
erDiagram
    USERS ||--o{ PROVIDER_CONFIGS : creates
    USERS ||--o{ PROVIDER_DISTRIBUTIONS : distributes
    USERS ||--o{ PROVIDER_DISTRIBUTIONS : receives
    USERS ||--o{ CONVERSATIONS : owns
    USERS ||--o{ AUDIT_LOGS : generates
    
    PROVIDER_CONFIGS ||--o{ PROVIDER_DISTRIBUTIONS : distributed
    PROVIDER_CONFIGS ||--o{ CONVERSATIONS : used_in
    PROVIDER_CONFIGS ||--o{ USAGE_STATISTICS : tracked
    
    CONVERSATIONS ||--o{ MESSAGES : contains
    CONVERSATIONS ||--o{ USAGE_STATISTICS : generates
    
    USERS {
        int id PK
        string username UK
        string email UK
        string hashed_password
        enum role
        boolean is_active
        timestamp created_at
        timestamp updated_at
    }
    
    PROVIDER_CONFIGS {
        int id PK
        string name
        enum provider_type
        enum scope
        int created_by FK
        string api_key
        string api_base_url
        json config
        boolean is_active
        timestamp created_at
        timestamp updated_at
    }
    
    PROVIDER_DISTRIBUTIONS {
        int id PK
        int provider_id FK
        int user_id FK
        int distributed_by FK
        timestamp distributed_at
        boolean is_active
    }
    
    CONVERSATIONS {
        int id PK
        int user_id FK
        int provider_id FK
        string title
        json metadata
        timestamp created_at
        timestamp updated_at
    }
    
    MESSAGES {
        int id PK
        int conversation_id FK
        enum role
        text content
        json metadata
        timestamp created_at
    }
    
    USAGE_STATISTICS {
        int id PK
        int user_id FK
        int provider_id FK
        int conversation_id FK
        int tokens_used
        decimal cost
        timestamp recorded_at
    }
    
    AUDIT_LOGS {
        int id PK
        int user_id FK
        string action
        string resource_type
        int resource_id
        json changes
        timestamp created_at
    }
```

---

## ğŸ“Š **æ ¸å¿ƒè¡¨ç»“æ„**

### **1. ç”¨æˆ·è¡¨ (users)**

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    hashed_password VARCHAR(255) NOT NULL,
    role VARCHAR(20) NOT NULL DEFAULT 'user' CHECK (role IN ('admin', 'user')),
    is_active BOOLEAN NOT NULL DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- ç´¢å¼•
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_role ON users(role);
CREATE INDEX idx_users_is_active ON users(is_active);

-- è§¦å‘å™¨ï¼šè‡ªåŠ¨æ›´æ–° updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_users_updated_at 
    BEFORE UPDATE ON users 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

**å­—æ®µè¯´æ˜**:
- `id`: ä¸»é”®ï¼Œè‡ªå¢
- `username`: ç”¨æˆ·åï¼Œå”¯ä¸€
- `email`: é‚®ç®±ï¼Œå”¯ä¸€
- `hashed_password`: åŠ å¯†åçš„å¯†ç 
- `role`: ç”¨æˆ·è§’è‰²ï¼Œæšä¸¾å€¼ï¼ˆadmin, userï¼‰
- `is_active`: æ˜¯å¦æ¿€æ´»
- `created_at`: åˆ›å»ºæ—¶é—´
- `updated_at`: æ›´æ–°æ—¶é—´

### **2. ä¾›åº”å•†é…ç½®è¡¨ (provider_configs)**

```sql
CREATE TABLE provider_configs (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    provider_type VARCHAR(20) NOT NULL CHECK (provider_type IN ('openai', 'anthropic', 'ollama', 'custom')),
    scope VARCHAR(20) NOT NULL CHECK (scope IN ('organization', 'personal')),
    created_by INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    api_key TEXT NOT NULL, -- åŠ å¯†å­˜å‚¨
    api_base_url VARCHAR(200),
    config JSONB DEFAULT '{}',
    is_active BOOLEAN NOT NULL DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    -- çº¦æŸï¼šç»„ç»‡çº§ä¾›åº”å•†åç§°å”¯ä¸€
    CONSTRAINT unique_org_provider_name UNIQUE (name, scope) 
        WHERE scope = 'organization',
    
    -- çº¦æŸï¼šä¸ªäººçº§ä¾›åº”å•†åœ¨åŒä¸€ç”¨æˆ·ä¸‹åç§°å”¯ä¸€
    CONSTRAINT unique_personal_provider_name UNIQUE (name, created_by, scope) 
        WHERE scope = 'personal'
);

-- ç´¢å¼•
CREATE INDEX idx_provider_configs_created_by ON provider_configs(created_by);
CREATE INDEX idx_provider_configs_scope ON provider_configs(scope);
CREATE INDEX idx_provider_configs_type ON provider_configs(provider_type);
CREATE INDEX idx_provider_configs_is_active ON provider_configs(is_active);
CREATE INDEX idx_provider_configs_name ON provider_configs(name);

-- è§¦å‘å™¨ï¼šè‡ªåŠ¨æ›´æ–° updated_at
CREATE TRIGGER update_provider_configs_updated_at 
    BEFORE UPDATE ON provider_configs 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

**å­—æ®µè¯´æ˜**:
- `id`: ä¸»é”®ï¼Œè‡ªå¢
- `name`: ä¾›åº”å•†åç§°
- `provider_type`: ä¾›åº”å•†ç±»å‹ï¼ˆopenai, anthropic, ollama, customï¼‰
- `scope`: ä½œç”¨åŸŸï¼ˆorganization, personalï¼‰
- `created_by`: åˆ›å»ºè€…IDï¼Œå¤–é”®å…³è”usersè¡¨
- `api_key`: APIå¯†é’¥ï¼ŒåŠ å¯†å­˜å‚¨
- `api_base_url`: APIåŸºç¡€URL
- `config`: ä¾›åº”å•†ç‰¹å®šé…ç½®ï¼ŒJSONæ ¼å¼
- `is_active`: æ˜¯å¦æ¿€æ´»

### **3. ä¾›åº”å•†åˆ†å‘è¡¨ (provider_distributions)**

```sql
CREATE TABLE provider_distributions (
    id SERIAL PRIMARY KEY,
    provider_id INTEGER NOT NULL REFERENCES provider_configs(id) ON DELETE CASCADE,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    distributed_by INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    distributed_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    is_active BOOLEAN NOT NULL DEFAULT true,
    
    -- çº¦æŸï¼šåŒä¸€ä¾›åº”å•†ä¸èƒ½é‡å¤åˆ†å‘ç»™åŒä¸€ç”¨æˆ·
    CONSTRAINT unique_provider_distribution UNIQUE (provider_id, user_id)
);

-- ç´¢å¼•
CREATE INDEX idx_provider_distributions_provider_id ON provider_distributions(provider_id);
CREATE INDEX idx_provider_distributions_user_id ON provider_distributions(user_id);
CREATE INDEX idx_provider_distributions_distributed_by ON provider_distributions(distributed_by);
CREATE INDEX idx_provider_distributions_is_active ON provider_distributions(is_active);

-- æ£€æŸ¥çº¦æŸï¼šåªæœ‰ç»„ç»‡çº§ä¾›åº”å•†å¯ä»¥è¢«åˆ†å‘
ALTER TABLE provider_distributions 
ADD CONSTRAINT check_only_org_providers_can_be_distributed 
CHECK (
    provider_id IN (
        SELECT id FROM provider_configs WHERE scope = 'organization'
    )
);
```

**å­—æ®µè¯´æ˜**:
- `id`: ä¸»é”®ï¼Œè‡ªå¢
- `provider_id`: ä¾›åº”å•†IDï¼Œå¤–é”®å…³è”provider_configsè¡¨
- `user_id`: ç”¨æˆ·IDï¼Œå¤–é”®å…³è”usersè¡¨
- `distributed_by`: åˆ†å‘è€…IDï¼Œå¤–é”®å…³è”usersè¡¨
- `distributed_at`: åˆ†å‘æ—¶é—´
- `is_active`: æ˜¯å¦æ¿€æ´»

### **4. å¯¹è¯è¡¨ (conversations)**

```sql
CREATE TABLE conversations (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    provider_id INTEGER NOT NULL REFERENCES provider_configs(id) ON DELETE CASCADE,
    title VARCHAR(200) NOT NULL,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- ç´¢å¼•
CREATE INDEX idx_conversations_user_id ON conversations(user_id);
CREATE INDEX idx_conversations_provider_id ON conversations(provider_id);
CREATE INDEX idx_conversations_created_at ON conversations(created_at);
CREATE INDEX idx_conversations_title ON conversations USING gin(to_tsvector('english', title));

-- è§¦å‘å™¨ï¼šè‡ªåŠ¨æ›´æ–° updated_at
CREATE TRIGGER update_conversations_updated_at 
    BEFORE UPDATE ON conversations 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

**å­—æ®µè¯´æ˜**:
- `id`: ä¸»é”®ï¼Œè‡ªå¢
- `user_id`: ç”¨æˆ·IDï¼Œå¤–é”®å…³è”usersè¡¨
- `provider_id`: ä¾›åº”å•†IDï¼Œå¤–é”®å…³è”provider_configsè¡¨
- `title`: å¯¹è¯æ ‡é¢˜
- `metadata`: å¯¹è¯å…ƒæ•°æ®ï¼ŒJSONæ ¼å¼
- `created_at`: åˆ›å»ºæ—¶é—´
- `updated_at`: æ›´æ–°æ—¶é—´

### **5. æ¶ˆæ¯è¡¨ (messages)**

```sql
CREATE TABLE messages (
    id SERIAL PRIMARY KEY,
    conversation_id INTEGER NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
    role VARCHAR(20) NOT NULL CHECK (role IN ('user', 'assistant', 'system')),
    content TEXT NOT NULL,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- ç´¢å¼•
CREATE INDEX idx_messages_conversation_id ON messages(conversation_id);
CREATE INDEX idx_messages_role ON messages(role);
CREATE INDEX idx_messages_created_at ON messages(created_at);
CREATE INDEX idx_messages_content ON messages USING gin(to_tsvector('english', content));

-- åˆ†åŒºï¼šæŒ‰åˆ›å»ºæ—¶é—´åˆ†åŒºï¼ˆå¯é€‰ï¼Œç”¨äºå¤§æ•°æ®é‡ï¼‰
-- CREATE TABLE messages_2025 PARTITION OF messages
-- FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');
```

**å­—æ®µè¯´æ˜**:
- `id`: ä¸»é”®ï¼Œè‡ªå¢
- `conversation_id`: å¯¹è¯IDï¼Œå¤–é”®å…³è”conversationsè¡¨
- `role`: æ¶ˆæ¯è§’è‰²ï¼ˆuser, assistant, systemï¼‰
- `content`: æ¶ˆæ¯å†…å®¹
- `metadata`: æ¶ˆæ¯å…ƒæ•°æ®ï¼ŒJSONæ ¼å¼
- `created_at`: åˆ›å»ºæ—¶é—´

### **6. ä½¿ç”¨ç»Ÿè®¡è¡¨ (usage_statistics)**

```sql
CREATE TABLE usage_statistics (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    provider_id INTEGER NOT NULL REFERENCES provider_configs(id) ON DELETE CASCADE,
    conversation_id INTEGER REFERENCES conversations(id) ON DELETE SET NULL,
    tokens_used INTEGER NOT NULL DEFAULT 0,
    cost DECIMAL(10,6) NOT NULL DEFAULT 0.000000,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- ç´¢å¼•
CREATE INDEX idx_usage_statistics_user_id ON usage_statistics(user_id);
CREATE INDEX idx_usage_statistics_provider_id ON usage_statistics(provider_id);
CREATE INDEX idx_usage_statistics_conversation_id ON usage_statistics(conversation_id);
CREATE INDEX idx_usage_statistics_recorded_at ON usage_statistics(recorded_at);

-- åˆ†åŒºï¼šæŒ‰æ—¶é—´åˆ†åŒº
CREATE TABLE usage_statistics_2025 PARTITION OF usage_statistics
FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');
```

**å­—æ®µè¯´æ˜**:
- `id`: ä¸»é”®ï¼Œè‡ªå¢
- `user_id`: ç”¨æˆ·IDï¼Œå¤–é”®å…³è”usersè¡¨
- `provider_id`: ä¾›åº”å•†IDï¼Œå¤–é”®å…³è”provider_configsè¡¨
- `conversation_id`: å¯¹è¯IDï¼Œå¤–é”®å…³è”conversationsè¡¨
- `tokens_used`: ä½¿ç”¨çš„tokenæ•°é‡
- `cost`: æˆæœ¬
- `recorded_at`: è®°å½•æ—¶é—´

### **7. å®¡è®¡æ—¥å¿—è¡¨ (audit_logs)**

```sql
CREATE TABLE audit_logs (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE SET NULL,
    action VARCHAR(50) NOT NULL,
    resource_type VARCHAR(50) NOT NULL,
    resource_id INTEGER,
    changes JSONB DEFAULT '{}',
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- ç´¢å¼•
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_action ON audit_logs(action);
CREATE INDEX idx_audit_logs_resource_type ON audit_logs(resource_type);
CREATE INDEX idx_audit_logs_resource_id ON audit_logs(resource_id);
CREATE INDEX idx_audit_logs_created_at ON audit_logs(created_at);

-- åˆ†åŒºï¼šæŒ‰æ—¶é—´åˆ†åŒº
CREATE TABLE audit_logs_2025 PARTITION OF audit_logs
FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');
```

**å­—æ®µè¯´æ˜**:
- `id`: ä¸»é”®ï¼Œè‡ªå¢
- `user_id`: ç”¨æˆ·IDï¼Œå¤–é”®å…³è”usersè¡¨
- `action`: æ“ä½œç±»å‹ï¼ˆcreate, update, delete, loginç­‰ï¼‰
- `resource_type`: èµ„æºç±»å‹ï¼ˆuser, provider, conversationç­‰ï¼‰
- `resource_id`: èµ„æºID
- `changes`: å˜æ›´å†…å®¹ï¼ŒJSONæ ¼å¼
- `ip_address`: IPåœ°å€
- `user_agent`: ç”¨æˆ·ä»£ç†
- `created_at`: åˆ›å»ºæ—¶é—´

---

## ğŸ”§ **è§†å›¾å’Œå‡½æ•°**

### **1. ç”¨æˆ·å¯ç”¨ä¾›åº”å•†è§†å›¾**

```sql
CREATE VIEW user_available_providers AS
SELECT DISTINCT
    pc.id,
    pc.name,
    pc.provider_type,
    pc.scope,
    pc.created_by,
    pc.api_base_url,
    pc.config,
    pc.is_active,
    pc.created_at,
    pc.updated_at,
    CASE 
        WHEN pc.scope = 'personal' THEN pc.created_by
        ELSE pd.user_id
    END AS available_to_user
FROM provider_configs pc
LEFT JOIN provider_distributions pd ON pc.id = pd.provider_id AND pd.is_active = true
WHERE pc.is_active = true
    AND (
        pc.scope = 'personal' 
        OR (pc.scope = 'organization' AND pd.user_id IS NOT NULL)
    );

-- ä½¿ç”¨ç¤ºä¾‹ï¼šè·å–ç”¨æˆ·IDä¸º1çš„æ‰€æœ‰å¯ç”¨ä¾›åº”å•†
-- SELECT * FROM user_available_providers WHERE available_to_user = 1;
```

### **2. ä¾›åº”å•†ä½¿ç”¨ç»Ÿè®¡è§†å›¾**

```sql
CREATE VIEW provider_usage_summary AS
SELECT 
    pc.id as provider_id,
    pc.name as provider_name,
    pc.provider_type,
    pc.scope,
    COUNT(DISTINCT us.user_id) as unique_users,
    SUM(us.tokens_used) as total_tokens,
    SUM(us.cost) as total_cost,
    AVG(us.tokens_used) as avg_tokens_per_request,
    AVG(us.cost) as avg_cost_per_request,
    MIN(us.recorded_at) as first_used_at,
    MAX(us.recorded_at) as last_used_at
FROM provider_configs pc
LEFT JOIN usage_statistics us ON pc.id = us.provider_id
WHERE pc.is_active = true
GROUP BY pc.id, pc.name, pc.provider_type, pc.scope;
```

### **3. æƒé™æ£€æŸ¥å‡½æ•°**

```sql
CREATE OR REPLACE FUNCTION can_user_access_provider(
    p_user_id INTEGER,
    p_provider_id INTEGER
) RETURNS BOOLEAN AS $$
DECLARE
    provider_scope VARCHAR(20);
    provider_creator INTEGER;
    is_distributed BOOLEAN;
BEGIN
    -- è·å–ä¾›åº”å•†ä¿¡æ¯
    SELECT scope, created_by INTO provider_scope, provider_creator
    FROM provider_configs 
    WHERE id = p_provider_id AND is_active = true;
    
    -- å¦‚æœä¾›åº”å•†ä¸å­˜åœ¨ï¼Œè¿”å›false
    IF NOT FOUND THEN
        RETURN FALSE;
    END IF;
    
    -- ä¸ªäººä¾›åº”å•†ï¼šåªæœ‰åˆ›å»ºè€…å¯ä»¥è®¿é—®
    IF provider_scope = 'personal' THEN
        RETURN provider_creator = p_user_id;
    END IF;
    
    -- ç»„ç»‡ä¾›åº”å•†ï¼šæ£€æŸ¥æ˜¯å¦å·²åˆ†å‘ç»™ç”¨æˆ·
    IF provider_scope = 'organization' THEN
        SELECT EXISTS(
            SELECT 1 FROM provider_distributions 
            WHERE provider_id = p_provider_id 
                AND user_id = p_user_id 
                AND is_active = true
        ) INTO is_distributed;
        
        RETURN is_distributed;
    END IF;
    
    RETURN FALSE;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨ç¤ºä¾‹ï¼šæ£€æŸ¥ç”¨æˆ·1æ˜¯å¦å¯ä»¥è®¿é—®ä¾›åº”å•†2
-- SELECT can_user_access_provider(1, 2);
```

---

## ğŸš€ **æ€§èƒ½ä¼˜åŒ–**

### **1. æŸ¥è¯¢ä¼˜åŒ–**

```sql
-- åˆ›å»ºå¤åˆç´¢å¼•ä¼˜åŒ–å¸¸ç”¨æŸ¥è¯¢
CREATE INDEX idx_provider_configs_scope_active ON provider_configs(scope, is_active);
CREATE INDEX idx_provider_distributions_user_active ON provider_distributions(user_id, is_active);
CREATE INDEX idx_conversations_user_provider ON conversations(user_id, provider_id);
CREATE INDEX idx_messages_conversation_created ON messages(conversation_id, created_at);

-- ä¼˜åŒ–å…¨æ–‡æœç´¢
CREATE INDEX idx_messages_content_gin ON messages USING gin(to_tsvector('english', content));
CREATE INDEX idx_conversations_title_gin ON conversations USING gin(to_tsvector('english', title));
```

### **2. åˆ†åŒºç­–ç•¥**

```sql
-- ä¸ºå¤§è¡¨å¯ç”¨åˆ†åŒº
-- ä½¿ç”¨ç»Ÿè®¡è¡¨æŒ‰æœˆåˆ†åŒº
CREATE TABLE usage_statistics_2025_01 PARTITION OF usage_statistics
FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

CREATE TABLE usage_statistics_2025_02 PARTITION OF usage_statistics
FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');

-- è‡ªåŠ¨åˆ›å»ºåˆ†åŒºçš„å‡½æ•°
CREATE OR REPLACE FUNCTION create_monthly_partition(
    table_name TEXT,
    start_date DATE
) RETURNS VOID AS $$
DECLARE
    partition_name TEXT;
    end_date DATE;
BEGIN
    partition_name := table_name || '_' || to_char(start_date, 'YYYY_MM');
    end_date := start_date + INTERVAL '1 month';
    
    EXECUTE format('CREATE TABLE %I PARTITION OF %I FOR VALUES FROM (%L) TO (%L)',
                   partition_name, table_name, start_date, end_date);
END;
$$ LANGUAGE plpgsql;
```

### **3. ç¼“å­˜ç­–ç•¥**

```sql
-- åˆ›å»ºç‰©åŒ–è§†å›¾ç”¨äºç¼“å­˜é¢‘ç¹æŸ¥è¯¢çš„æ•°æ®
CREATE MATERIALIZED VIEW mv_provider_usage_daily AS
SELECT 
    DATE(recorded_at) as usage_date,
    provider_id,
    SUM(tokens_used) as daily_tokens,
    SUM(cost) as daily_cost,
    COUNT(*) as daily_requests
FROM usage_statistics
GROUP BY DATE(recorded_at), provider_id;

-- åˆ›å»ºå”¯ä¸€ç´¢å¼•æ”¯æŒå¹¶å‘åˆ·æ–°
CREATE UNIQUE INDEX idx_mv_provider_usage_daily ON mv_provider_usage_daily(usage_date, provider_id);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
-- å¯ä»¥é€šè¿‡cron jobè°ƒç”¨ï¼šREFRESH MATERIALIZED VIEW CONCURRENTLY mv_provider_usage_daily;
```

---

## ğŸ” **å®‰å…¨é…ç½®**

### **1. æ•°æ®åŠ å¯†**

```sql
-- å¯ç”¨æ•°æ®åŠ å¯†æ‰©å±•
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- åˆ›å»ºåŠ å¯†å‡½æ•°
CREATE OR REPLACE FUNCTION encrypt_api_key(api_key TEXT) RETURNS TEXT AS $$
BEGIN
    RETURN crypt(api_key, gen_salt('bf'));
END;
$$ LANGUAGE plpgsql;

-- åˆ›å»ºè§£å¯†å‡½æ•°ï¼ˆå®é™…ä½¿ç”¨ä¸­åº”è¯¥åœ¨åº”ç”¨å±‚å¤„ç†ï¼‰
CREATE OR REPLACE FUNCTION decrypt_api_key(encrypted_key TEXT, plain_key TEXT) RETURNS BOOLEAN AS $$
BEGIN
    RETURN encrypted_key = crypt(plain_key, encrypted_key);
END;
$$ LANGUAGE plpgsql;
```

### **2. è¡Œçº§å®‰å…¨ç­–ç•¥**

```sql
-- å¯ç”¨è¡Œçº§å®‰å…¨
ALTER TABLE provider_configs ENABLE ROW LEVEL SECURITY;
ALTER TABLE conversations ENABLE ROW LEVEL SECURITY;
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;

-- åˆ›å»ºå®‰å…¨ç­–ç•¥ï¼šç”¨æˆ·åªèƒ½è®¿é—®è‡ªå·±çš„æ•°æ®
CREATE POLICY user_provider_access ON provider_configs
    FOR ALL TO authenticated_users
    USING (
        -- ä¸ªäººä¾›åº”å•†ï¼šåªæœ‰åˆ›å»ºè€…å¯ä»¥è®¿é—®
        (scope = 'personal' AND created_by = current_user_id()) OR
        -- ç»„ç»‡ä¾›åº”å•†ï¼šæ£€æŸ¥åˆ†å‘æƒé™
        (scope = 'organization' AND can_user_access_provider(current_user_id(), id))
    );

-- åˆ›å»ºè·å–å½“å‰ç”¨æˆ·IDçš„å‡½æ•°
CREATE OR REPLACE FUNCTION current_user_id() RETURNS INTEGER AS $$
BEGIN
    RETURN COALESCE(current_setting('app.current_user_id', true)::INTEGER, 0);
END;
$$ LANGUAGE plpgsql;
```

---

## ğŸ“Š **ç›‘æ§å’Œç»´æŠ¤**

### **1. ç›‘æ§æŸ¥è¯¢**

```sql
-- æ´»è·ƒç”¨æˆ·ç»Ÿè®¡
SELECT 
    COUNT(DISTINCT user_id) as active_users_today
FROM usage_statistics 
WHERE recorded_at >= CURRENT_DATE;

-- ä¾›åº”å•†ä½¿ç”¨æ’è¡Œ
SELECT 
    pc.name,
    COUNT(*) as usage_count,
    SUM(us.tokens_used) as total_tokens,
    SUM(us.cost) as total_cost
FROM usage_statistics us
JOIN provider_configs pc ON us.provider_id = pc.id
WHERE us.recorded_at >= CURRENT_DATE - INTERVAL '7 days'
GROUP BY pc.id, pc.name
ORDER BY usage_count DESC;

-- ç³»ç»Ÿå¥åº·æ£€æŸ¥
SELECT 
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size,
    pg_stat_get_live_tuples(c.oid) as live_tuples,
    pg_stat_get_dead_tuples(c.oid) as dead_tuples
FROM pg_tables pt
JOIN pg_class c ON c.relname = pt.tablename
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
```

### **2. ç»´æŠ¤è„šæœ¬**

```sql
-- æ¸…ç†è¿‡æœŸæ•°æ®
DELETE FROM audit_logs WHERE created_at < CURRENT_DATE - INTERVAL '1 year';
DELETE FROM usage_statistics WHERE recorded_at < CURRENT_DATE - INTERVAL '2 years';

-- é‡å»ºç»Ÿè®¡ä¿¡æ¯
ANALYZE users;
ANALYZE provider_configs;
ANALYZE conversations;
ANALYZE messages;
ANALYZE usage_statistics;

-- æ¸…ç†æ— æ•ˆçš„ä¼šè¯
DELETE FROM conversations 
WHERE id NOT IN (
    SELECT DISTINCT conversation_id 
    FROM messages 
    WHERE conversation_id IS NOT NULL
);
```

---

## ğŸ”„ **æ•°æ®åº“è¿ç§»**

### **Alembic è¿ç§»è„šæœ¬ç¤ºä¾‹**

```python
"""åˆå§‹åŒ–æ•°æ®åº“

Revision ID: 001
Revises: 
Create Date: 2025-07-07 12:00:00.000000

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers
revision = '001'
down_revision = None
branch_labels = None
depends_on = None

def upgrade():
    # åˆ›å»ºç”¨æˆ·è¡¨
    op.create_table(
        'users',
        sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),
        sa.Column('username', sa.String(length=50), nullable=False),
        sa.Column('email', sa.String(length=100), nullable=False),
        sa.Column('hashed_password', sa.String(length=255), nullable=False),
        sa.Column('role', sa.String(length=20), nullable=False),
        sa.Column('is_active', sa.Boolean(), nullable=False),
        sa.Column('created_at', sa.TIMESTAMP(timezone=True), server_default=sa.text('CURRENT_TIMESTAMP')),
        sa.Column('updated_at', sa.TIMESTAMP(timezone=True), server_default=sa.text('CURRENT_TIMESTAMP')),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('email'),
        sa.UniqueConstraint('username'),
        sa.CheckConstraint("role IN ('admin', 'user')", name='check_user_role')
    )
    
    # åˆ›å»ºä¾›åº”å•†é…ç½®è¡¨
    op.create_table(
        'provider_configs',
        sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),
        sa.Column('name', sa.String(length=100), nullable=False),
        sa.Column('provider_type', sa.String(length=20), nullable=False),
        sa.Column('scope', sa.String(length=20), nullable=False),
        sa.Column('created_by', sa.Integer(), nullable=False),
        sa.Column('api_key', sa.Text(), nullable=False),
        sa.Column('api_base_url', sa.String(length=200), nullable=True),
        sa.Column('config', postgresql.JSONB(), nullable=True),
        sa.Column('is_active', sa.Boolean(), nullable=False),
        sa.Column('created_at', sa.TIMESTAMP(timezone=True), server_default=sa.text('CURRENT_TIMESTAMP')),
        sa.Column('updated_at', sa.TIMESTAMP(timezone=True), server_default=sa.text('CURRENT_TIMESTAMP')),
        sa.ForeignKeyConstraint(['created_by'], ['users.id'], ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('id'),
        sa.CheckConstraint("provider_type IN ('openai', 'anthropic', 'ollama', 'custom')", name='check_provider_type'),
        sa.CheckConstraint("scope IN ('organization', 'personal')", name='check_provider_scope')
    )
    
    # åˆ›å»ºç´¢å¼•
    op.create_index('idx_users_username', 'users', ['username'])
    op.create_index('idx_users_email', 'users', ['email'])
    op.create_index('idx_provider_configs_created_by', 'provider_configs', ['created_by'])
    op.create_index('idx_provider_configs_scope', 'provider_configs', ['scope'])

def downgrade():
    op.drop_table('provider_configs')
    op.drop_table('users')
```

---

## ğŸ“ **æ€»ç»“**

è¿™ä¸ªæ•°æ®åº“è®¾è®¡å……åˆ†ä½“ç°äº†ä¾›åº”å•†ä½œç”¨åŸŸæ¶æ„çš„æ ¸å¿ƒç†å¿µï¼š

1. **æ¸…æ™°çš„æƒé™æ§åˆ¶**: é€šè¿‡ `scope` å­—æ®µå’Œç›¸å…³çº¦æŸï¼Œå®ç°äº†ç®€å•è€Œå¼ºå¤§çš„æƒé™ç®¡ç†
2. **æ€§èƒ½ä¼˜åŒ–**: é€šè¿‡åˆç†çš„ç´¢å¼•ã€åˆ†åŒºå’Œç¼“å­˜ç­–ç•¥ï¼Œç¡®ä¿é«˜æ€§èƒ½
3. **å®‰å…¨æ€§**: æ•æ„Ÿæ•°æ®åŠ å¯†ã€è¡Œçº§å®‰å…¨ç­–ç•¥å’Œå®¡è®¡æ—¥å¿—
4. **å¯æ‰©å±•æ€§**: æ”¯æŒæ°´å¹³æ‰©å±•å’ŒåŠŸèƒ½æ‰©å±•
5. **å¯ç»´æŠ¤æ€§**: æ¸…æ™°çš„è¡¨ç»“æ„å’Œå®Œå–„çš„ç»´æŠ¤è„šæœ¬

è¿™ä¸ªè®¾è®¡ä¸º LYSS AI å¹³å°æä¾›äº†åšå®çš„æ•°æ®åŸºç¡€ï¼Œæ”¯æŒå¹³å°çš„é•¿æœŸå‘å±•å’Œæ‰©å±•ã€‚