# Lyss AI Platform 开发方案和规范文档

## 📋 项目概述

**项目名称**: Lyss AI Platform  
**项目定位**: 企业级AI服务聚合与管理平台  
**技术架构**: 微服务架构 + 多租户SaaS模式  
**开发语言**: Python (FastAPI), Go (EINO), TypeScript (React)  

## 🎯 开发战略和优先级

### 第一阶段：核心业务功能 (2-3周)
**目标**: 实现平台的基础功能，让用户能够正常使用AI对话服务

#### 1.1 对话管理系统 (优先级: HIGH)
**开发时间**: 1周  
**负责模块**: Backend  
**核心功能**:
- 对话CRUD操作 (创建、读取、更新、删除)
- 消息管理和持久化存储
- 对话搜索和分页功能
- 对话导出和归档功能
- 对话权限控制和共享

**技术要求**:
- 使用FastAPI构建RESTful API
- PostgreSQL存储对话和消息数据
- Redis缓存热点对话数据
- 支持流式响应和WebSocket实时通信

#### 1.2 AI服务集成层 (优先级: HIGH)
**开发时间**: 1.5周  
**负责模块**: Backend  
**核心功能**:
- 多AI供应商统一抽象层 (OpenAI、Anthropic、Google等)
- 模型配置和管理系统
- 流式响应处理和转换
- 成本计算和使用限额管理
- 供应商负载均衡和故障转移

**技术要求**:
- 采用策略模式实现供应商抽象
- 支持异步HTTP请求处理
- 实现熔断器和重试机制
- 集成成本计算和监控

#### 1.3 基础前端界面 (优先级: HIGH)
**开发时间**: 1周  
**负责模块**: Frontend  
**核心功能**:
- 用户登录和注册页面
- 基础对话界面 (聊天窗口、消息列表)
- 简单的用户设置页面
- 基本的租户管理界面

**技术要求**:
- 使用React + TypeScript开发
- 采用Ant Design + Ant Design X UI组件
- 实现响应式设计
- 集成JWT认证

### 第二阶段：增强功能 (2-3周)
**目标**: 完善平台的高级功能，提升用户体验

#### 2.1 Memory服务完善 (优先级: MEDIUM)
**开发时间**: 1.5周  
**负责模块**: Memory Service  
**核心功能**:
- 基于Mem0AI的智能记忆管理
- 向量搜索和语义相似度匹配
- 记忆分类、标签和权重管理
- 记忆过期和清理机制

#### 2.2 EINO工作流服务 (优先级: MEDIUM)
**开发时间**: 1.5周  
**负责模块**: EINO Service  
**核心功能**:
- OptimizedRAG工作流实现
- 工具调用和函数集成
- 工作流编排和调度引擎
- 工作流监控和日志

#### 2.3 管理后台功能 (优先级: MEDIUM)
**开发时间**: 1周  
**负责模块**: Frontend + Backend  
**核心功能**:
- 租户管理和配置界面
- 用户管理和权限分配
- 使用统计和分析报表
- 系统监控和告警

### 第三阶段：高级企业功能 (2-3周)
**目标**: 实现企业级高级功能，满足大客户需求

#### 3.1 高级企业功能
- 审计日志可视化和分析
- 高级分析和自定义报表
- SSO单点登录集成
- Webhook和API集成
- 数据导出和备份功能

## 📐 开发规范和标准

### 代码规范

#### Python代码规范 (Backend)
```python
# 文件头部注释模板
"""
Lyss AI Platform - 模块名称
功能描述: 详细描述模块功能
作者: 开发者姓名
创建时间: 2025-07-09
最后更新: 2025-07-09
"""

# 导入顺序
import os
import sys
from datetime import datetime
from typing import List, Dict, Optional

from fastapi import FastAPI, HTTPException
from sqlalchemy import select

from common.database import get_async_session
from common.models import User, Conversation

# 类定义规范
class ConversationService:
    """对话服务类
    
    负责处理对话相关的业务逻辑，包括创建、更新、删除等操作
    """
    
    def __init__(self, db_session):
        """初始化对话服务
        
        Args:
            db_session: 数据库会话对象
        """
        self.db_session = db_session
    
    async def create_conversation(self, user_id: str, title: str) -> Conversation:
        """创建新对话
        
        Args:
            user_id: 用户ID
            title: 对话标题
            
        Returns:
            Conversation: 创建的对话对象
            
        Raises:
            ValueError: 当参数无效时抛出
        """
        # 实现逻辑
        pass

# 函数定义规范
async def get_conversation_by_id(conversation_id: str) -> Optional[Conversation]:
    """根据ID获取对话
    
    Args:
        conversation_id: 对话ID
        
    Returns:
        Optional[Conversation]: 对话对象，如果不存在则返回None
    """
    # 实现逻辑
    pass

# 常量定义
DEFAULT_PAGE_SIZE = 20
MAX_PAGE_SIZE = 100
DEFAULT_CONVERSATION_TITLE = "新对话"

# 错误处理规范
try:
    result = await some_async_operation()
except ValueError as e:
    logger.error(f"参数错误: {e}")
    raise HTTPException(status_code=400, detail=f"参数错误: {e}")
except Exception as e:
    logger.error(f"未知错误: {e}")
    raise HTTPException(status_code=500, detail="内部服务器错误")
```

#### Go代码规范 (EINO Service)
```go
// 文件头部注释模板
/*
Lyss AI Platform - EINO服务
功能描述: AI工作流编排和管理
作者: 开发者姓名
创建时间: 2025-07-09
最后更新: 2025-07-09
*/

package services

import (
    "context"
    "fmt"
    "time"

    "github.com/cloudwego/eino"
    "github.com/google/uuid"
)

// 常量定义
const (
    DefaultTimeout = 30 * time.Second
    MaxRetries     = 3
    DefaultModel   = "gpt-4"
)

// 结构体定义
type WorkflowService struct {
    client eino.Client
    config *WorkflowConfig
}

// WorkflowConfig 工作流配置
type WorkflowConfig struct {
    Model       string        `json:"model"`
    Temperature float64       `json:"temperature"`
    MaxTokens   int           `json:"max_tokens"`
    Timeout     time.Duration `json:"timeout"`
}

// NewWorkflowService 创建工作流服务实例
func NewWorkflowService(client eino.Client, config *WorkflowConfig) *WorkflowService {
    return &WorkflowService{
        client: client,
        config: config,
    }
}

// ProcessConversation 处理对话工作流
func (s *WorkflowService) ProcessConversation(ctx context.Context, req *ConversationRequest) (*ConversationResponse, error) {
    // 参数验证
    if req == nil {
        return nil, fmt.Errorf("请求参数不能为空")
    }
    
    if req.ConversationID == "" {
        return nil, fmt.Errorf("对话ID不能为空")
    }
    
    // 业务逻辑实现
    response, err := s.processWorkflow(ctx, req)
    if err != nil {
        return nil, fmt.Errorf("处理工作流失败: %w", err)
    }
    
    return response, nil
}

// 私有方法使用小写开头
func (s *WorkflowService) processWorkflow(ctx context.Context, req *ConversationRequest) (*ConversationResponse, error) {
    // 实现逻辑
    return nil, nil
}
```

#### TypeScript代码规范 (Frontend)
```typescript
/**
 * Lyss AI Platform - 前端组件
 * 功能描述: 对话界面组件
 * 作者: 开发者姓名
 * 创建时间: 2025-07-09
 * 最后更新: 2025-07-09
 */

import React, { useState, useEffect, useCallback } from 'react';
import { Button, Input, List, message } from 'antd';
import { SendOutlined, DeleteOutlined } from '@ant-design/icons';
import { useAuth } from '@/hooks/useAuth';
import { conversationService } from '@/services/conversationService';
import type { Conversation, Message } from '@/types';

// 接口定义
interface ConversationComponentProps {
  conversationId: string;
  onMessageSent?: (message: Message) => void;
  className?: string;
}

// 常量定义
const DEFAULT_PAGE_SIZE = 20;
const MAX_MESSAGE_LENGTH = 2000;

// 组件定义
const ConversationComponent: React.FC<ConversationComponentProps> = ({
  conversationId,
  onMessageSent,
  className,
}) => {
  // 状态定义
  const [messages, setMessages] = useState<Message[]>([]);
  const [inputValue, setInputValue] = useState('');
  const [loading, setLoading] = useState(false);
  const [conversation, setConversation] = useState<Conversation | null>(null);
  
  // 钩子使用
  const { user } = useAuth();
  
  // 副作用处理
  useEffect(() => {
    if (conversationId) {
      loadConversation();
      loadMessages();
    }
  }, [conversationId]);
  
  // 回调函数定义
  const loadConversation = useCallback(async () => {
    try {
      const conv = await conversationService.getById(conversationId);
      setConversation(conv);
    } catch (error) {
      message.error('加载对话失败');
      console.error('加载对话错误:', error);
    }
  }, [conversationId]);
  
  const loadMessages = useCallback(async () => {
    try {
      setLoading(true);
      const msgs = await conversationService.getMessages(conversationId);
      setMessages(msgs);
    } catch (error) {
      message.error('加载消息失败');
      console.error('加载消息错误:', error);
    } finally {
      setLoading(false);
    }
  }, [conversationId]);
  
  const handleSendMessage = useCallback(async () => {
    if (!inputValue.trim()) {
      message.warning('请输入消息内容');
      return;
    }
    
    if (inputValue.length > MAX_MESSAGE_LENGTH) {
      message.error(`消息长度不能超过 ${MAX_MESSAGE_LENGTH} 个字符`);
      return;
    }
    
    try {
      setLoading(true);
      const newMessage = await conversationService.sendMessage(
        conversationId,
        inputValue.trim()
      );
      
      setMessages(prev => [...prev, newMessage]);
      setInputValue('');
      onMessageSent?.(newMessage);
      
      message.success('消息发送成功');
    } catch (error) {
      message.error('发送消息失败');
      console.error('发送消息错误:', error);
    } finally {
      setLoading(false);
    }
  }, [conversationId, inputValue, onMessageSent]);
  
  // 渲染函数
  return (
    <div className={`conversation-component ${className || ''}`}>
      <div className="conversation-header">
        <h3>{conversation?.title || '对话'}</h3>
      </div>
      
      <div className="messages-container">
        <List
          loading={loading}
          dataSource={messages}
          renderItem={(message) => (
            <List.Item key={message.id}>
              <div className={`message ${message.role}`}>
                <div className="message-content">{message.content}</div>
                <div className="message-time">
                  {new Date(message.createdAt).toLocaleString()}
                </div>
              </div>
            </List.Item>
          )}
        />
      </div>
      
      <div className="input-container">
        <Input.TextArea
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          placeholder="请输入消息..."
          rows={3}
          maxLength={MAX_MESSAGE_LENGTH}
          onPressEnter={(e) => {
            if (e.shiftKey) return;
            e.preventDefault();
            handleSendMessage();
          }}
        />
        <Button
          type="primary"
          icon={<SendOutlined />}
          onClick={handleSendMessage}
          loading={loading}
          disabled={!inputValue.trim()}
        >
          发送
        </Button>
      </div>
    </div>
  );
};

export default ConversationComponent;
```

### API响应规范

#### 统一响应格式
```json
{
  "success": true,
  "data": {},
  "message": "操作成功",
  "request_id": "550e8400-e29b-41d4-a716-446655440000",
  "timestamp": "2025-07-09T10:30:00.000Z",
  "errors": []
}
```

#### 错误响应格式
```json
{
  "success": false,
  "data": null,
  "message": "操作失败",
  "request_id": "550e8400-e29b-41d4-a716-446655440000",
  "timestamp": "2025-07-09T10:30:00.000Z",
  "errors": [
    {
      "code": "VALIDATION_ERROR",
      "message": "参数验证失败",
      "field": "email",
      "details": {
        "expected": "valid email format",
        "actual": "invalid-email"
      }
    }
  ]
}
```

#### 分页响应格式
```json
{
  "success": true,
  "data": {
    "items": [...],
    "pagination": {
      "page": 1,
      "page_size": 20,
      "total_count": 100,
      "total_pages": 5,
      "has_next": true,
      "has_previous": false
    }
  },
  "message": "获取数据成功"
}
```

### 数据库规范

#### 表命名规范
- 使用复数形式: `users`, `conversations`, `messages`
- 使用下划线分隔: `user_roles`, `ai_credentials`
- 避免缩写: `conversations` 而不是 `convs`

#### 字段命名规范
- 使用下划线分隔: `user_id`, `created_at`, `updated_at`
- 主键统一使用 `{table_name}_id` 格式
- 时间戳字段: `created_at`, `updated_at`, `deleted_at`
- 布尔字段使用 `is_` 前缀: `is_active`, `is_deleted`

#### 索引规范
```sql
-- 单字段索引
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_conversations_user_id ON conversations(user_id);

-- 复合索引
CREATE INDEX idx_messages_conversation_created ON messages(conversation_id, created_at);
CREATE INDEX idx_users_tenant_status ON users(tenant_id, status);

-- 唯一约束
CREATE UNIQUE INDEX idx_users_email_unique ON users(email);
CREATE UNIQUE INDEX idx_tenants_slug_unique ON tenants(tenant_slug);
```

### 日志规范

#### 日志级别
- `DEBUG`: 详细的调试信息
- `INFO`: 一般信息记录
- `WARNING`: 警告信息
- `ERROR`: 错误信息
- `CRITICAL`: 严重错误

#### 日志格式
```python
import logging
import structlog

# 配置结构化日志
structlog.configure(
    processors=[
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.add_log_level,
        structlog.processors.JSONRenderer()
    ],
    wrapper_class=structlog.make_filtering_bound_logger(logging.INFO),
    logger_factory=structlog.WriteLoggerFactory(),
    cache_logger_on_first_use=True,
)

logger = structlog.get_logger()

# 使用示例
logger.info("用户登录成功", user_id=user_id, tenant_id=tenant_id, ip_address=ip)
logger.error("数据库连接失败", error=str(e), database_url=db_url)
logger.warning("API调用频率过高", user_id=user_id, current_rate=rate, limit=limit)
```

## 🔧 开发工具和环境

### 开发环境配置

#### Python环境
```bash
# 创建虚拟环境
python -m venv venv
source venv/bin/activate  # Linux/Mac
venv\Scripts\activate     # Windows

# 安装依赖
pip install -r requirements.txt

# 代码格式化
black . --line-length 88
isort .

# 类型检查
mypy .

# 测试
pytest tests/ --cov=. --cov-report=html
```

#### Go环境
```bash
# 初始化Go模块
go mod init github.com/lyss-ai/eino-service

# 安装依赖
go mod download

# 代码格式化
go fmt ./...

# 代码检查
golangci-lint run

# 测试
go test ./... -v -race -coverprofile=coverage.out
```

#### Node.js环境
```bash
# 安装依赖
npm install

# 代码格式化
npm run format

# 类型检查
npm run type-check

# 测试
npm run test

# 构建
npm run build
```

### Git规范

#### 提交信息格式
```
<type>(<scope>): <subject>

<body>

<footer>
```

#### 类型说明
- `feat`: 新功能
- `fix`: 修复bug
- `docs`: 文档更新
- `style`: 代码格式调整
- `refactor`: 重构代码
- `test`: 测试相关
- `chore`: 构建/工具相关

#### 提交示例
```
feat(auth): 添加JWT令牌刷新功能

- 实现刷新令牌的生成和验证
- 添加令牌过期时间配置
- 更新认证中间件支持令牌刷新

Closes #123
```

### 测试规范

#### 单元测试
```python
# Python测试示例
import pytest
from unittest.mock import Mock, patch
from fastapi.testclient import TestClient

from main import app
from services.conversation_service import ConversationService

client = TestClient(app)

class TestConversationService:
    """对话服务测试类"""
    
    def test_create_conversation_success(self):
        """测试创建对话成功"""
        # 准备测试数据
        user_id = "test-user-id"
        title = "测试对话"
        
        # 模拟依赖
        with patch('services.conversation_service.get_async_session') as mock_session:
            mock_session.return_value = Mock()
            
            # 执行测试
            service = ConversationService(mock_session.return_value)
            result = service.create_conversation(user_id, title)
            
            # 验证结果
            assert result is not None
            assert result.title == title
            assert result.user_id == user_id
    
    def test_create_conversation_invalid_params(self):
        """测试创建对话参数无效"""
        service = ConversationService(Mock())
        
        # 测试空用户ID
        with pytest.raises(ValueError, match="用户ID不能为空"):
            service.create_conversation("", "测试对话")
        
        # 测试空标题
        with pytest.raises(ValueError, match="标题不能为空"):
            service.create_conversation("user-id", "")
```

#### 集成测试
```python
# 集成测试示例
def test_conversation_api_flow():
    """测试对话API完整流程"""
    # 1. 用户登录
    login_response = client.post("/api/v1/auth/login", json={
        "email": "test@example.com",
        "password": "password123"
    })
    assert login_response.status_code == 200
    
    token = login_response.json()["data"]["access_token"]
    headers = {"Authorization": f"Bearer {token}"}
    
    # 2. 创建对话
    create_response = client.post("/api/v1/conversations", 
        json={"title": "测试对话"}, 
        headers=headers
    )
    assert create_response.status_code == 201
    
    conversation_id = create_response.json()["data"]["conversation_id"]
    
    # 3. 发送消息
    message_response = client.post(f"/api/v1/conversations/{conversation_id}/messages",
        json={"content": "你好", "role": "user"},
        headers=headers
    )
    assert message_response.status_code == 201
    
    # 4. 获取消息列表
    messages_response = client.get(f"/api/v1/conversations/{conversation_id}/messages",
        headers=headers
    )
    assert messages_response.status_code == 200
    assert len(messages_response.json()["data"]["messages"]) > 0
```

## 📊 性能和监控

### 性能指标
- API响应时间 < 500ms (P95)
- 数据库查询时间 < 100ms (P95)
- 系统内存使用率 < 80%
- CPU使用率 < 70%
- 错误率 < 1%

### 监控配置
```python
# Prometheus指标配置
from prometheus_client import Counter, Histogram, Gauge

# 定义指标
REQUEST_COUNT = Counter('http_requests_total', 'Total HTTP requests', ['method', 'endpoint', 'status'])
REQUEST_DURATION = Histogram('http_request_duration_seconds', 'HTTP request duration')
ACTIVE_CONNECTIONS = Gauge('active_connections', 'Number of active connections')

# 使用示例
@REQUEST_DURATION.time()
async def process_request():
    REQUEST_COUNT.labels(method='POST', endpoint='/api/v1/conversations', status='200').inc()
    # 处理请求逻辑
```

### 告警规则
```yaml
# Prometheus告警规则
groups:
  - name: lyss-ai-platform
    rules:
      - alert: HighErrorRate
        expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.01
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "高错误率告警"
          description: "错误率超过1%"
      
      - alert: HighResponseTime
        expr: histogram_quantile(0.95, http_request_duration_seconds) > 0.5
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "响应时间过长"
          description: "95%的请求响应时间超过500ms"
```

## 🚀 部署和运维

### Docker配置
```dockerfile
# Python服务Dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8000

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### Docker Compose配置
```yaml
version: '3.8'

services:
  backend:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:password@postgres:5432/lyss_db
      - REDIS_URL=redis://redis:6379/0
    depends_on:
      - postgres
      - redis
  
  postgres:
    image: pgvector/pgvector:pg16
    environment:
      - POSTGRES_DB=lyss_db
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
  
  redis:
    image: redis:8.0-alpine
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
```

### CI/CD配置
```yaml
# GitHub Actions配置
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install -r requirements-dev.txt
      
      - name: Run tests
        run: |
          pytest tests/ --cov=. --cov-report=xml
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
  
  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Deploy to production
        run: |
          # 部署脚本
          echo "部署到生产环境"
```

这个开发方案和规范文档提供了完整的开发指导，包括优先级规划、代码规范、API设计、测试策略、性能监控和部署运维等各个方面。