# EINO Service æŠ€æœ¯è§„èŒƒæ–‡æ¡£

## ğŸ¯ æœåŠ¡æ¦‚è¿°

EINO Service æ˜¯ Lyss AI Platform çš„**AIæ¨¡å‹ç¼–æ’ä¸è°ƒç”¨æ ¸å¿ƒ**ï¼ŒåŸºäºå­—èŠ‚è·³åŠ¨å¼€æºçš„CloudWeGo EINOæ¡†æ¶æ„å»ºã€‚EINOæ˜¯ä¸“ä¸ºGolangè®¾è®¡çš„å¤§è¯­è¨€æ¨¡å‹åº”ç”¨å¼€å‘æ¡†æ¶ï¼Œå¼ºè°ƒç±»å‹å®‰å…¨çš„ç»„ä»¶ç¼–æ’ï¼Œä¸ºä¼ä¸šçº§AIåº”ç”¨æä¾›å¯é ã€é«˜æ•ˆçš„å¼€å‘ä½“éªŒã€‚

### EINOæ¡†æ¶æ ¸å¿ƒç‰¹æ€§ (2025å¹´æœ€æ–°)

1. **GoåŸç”Ÿç±»å‹å®‰å…¨** - é€šè¿‡ç¼–è¯‘æœŸç±»å‹æ£€æŸ¥ç¡®ä¿ç»„ä»¶é—´æ•°æ®æµæ­£ç¡®æ€§ï¼Œé¿å…è¿è¡Œæ—¶é”™è¯¯
2. **ç»„ä»¶æŠ½è±¡åˆ†ç¦»** - æ ¸å¿ƒeinoåº“æä¾›æ¥å£æŠ½è±¡ï¼Œeino-extåº“æä¾›å…·ä½“å®ç°ï¼Œæ¶æ„æ¸…æ™°
3. **å¼ºå¤§ç¼–æ’å¼•æ“** - æ”¯æŒChain(é“¾å¼)å’ŒGraph(å›¾å¼)ä¸¤ç§ç¼–æ’æ¨¡å¼ï¼Œæ»¡è¶³ä¸åŒå¤æ‚åº¦éœ€æ±‚
4. **æµå¼å¤„ç†åŸç”Ÿæ”¯æŒ** - è‡ªåŠ¨å¤„ç†æµå¼å’Œéæµå¼æ•°æ®è½¬æ¢ï¼Œç®€åŒ–å¼€å‘å¤æ‚åº¦
5. **ä¼ä¸šçº§ç”Ÿäº§å°±ç»ª** - å·²åœ¨å­—èŠ‚è·³åŠ¨å†…éƒ¨å¹¿æ³›åº”ç”¨ï¼ŒåŒ…æ‹¬è±†åŒ…ã€æŠ–éŸ³ã€æ‰£å­ç­‰å¤šæ¡ä¸šåŠ¡çº¿

## ğŸ“‹ æ ¸å¿ƒèŒè´£ä¸æ¶æ„å®šä½

### ğŸ¯ æœåŠ¡å®šä½
EINO Serviceåœ¨Lyss AI Platformå¾®æœåŠ¡æ¶æ„ä¸­çš„å®šä½æ˜¯**AIå·¥ä½œæµç¼–æ’ä¸æ‰§è¡Œå¼•æ“**ï¼Œä¸“æ³¨äºå°†AIèƒ½åŠ›é€šè¿‡EINOæ¡†æ¶å°è£…æˆå¯å¤ç”¨çš„æœåŠ¡ç»„ä»¶ï¼Œä¾›API Gatewayè·¯ç”±åˆ†å‘ç»™å‰ç«¯ä½¿ç”¨ã€‚

### âœ… è´Ÿè´£çš„åŠŸèƒ½
1. **AIå·¥ä½œæµç¼–æ’**: ä½¿ç”¨EINO Chain/Graphæ„å»ºå¤æ‚çš„AIå¤„ç†æµç¨‹
2. **å¤šä¾›åº”å•†æ¨¡å‹è°ƒç”¨**: ç»Ÿä¸€å°è£…OpenAIã€Anthropicã€Volcengine Arkã€DeepSeekç­‰
3. **æ™ºèƒ½å‡­è¯é€‰æ‹©**: åŸºäºç§Ÿæˆ·å‡­è¯è¿›è¡Œè´Ÿè½½å‡è¡¡å’Œæ•…éšœè½¬ç§»
4. **æµå¼å’Œéæµå¼å“åº”**: æ”¯æŒæ ‡å‡†å“åº”å’ŒServer-Sent Eventsæµå¼è¾“å‡º  
5. **æœ¬åœ°å‡­è¯ç¼“å­˜**: ä¼˜åŒ–å‡­è¯è·å–æ€§èƒ½ï¼Œå‡å°‘å¯¹Tenant Serviceçš„è°ƒç”¨
6. **å¥åº·æ£€æŸ¥å’Œç›‘æ§**: ç›‘æ§AIæœåŠ¡å•†å¯ç”¨æ€§ï¼ŒåŠæ—¶å‘ç°é—®é¢˜

### âŒ ä¸è´Ÿè´£çš„åŠŸèƒ½
- **ç”¨æˆ·è®¤è¯å’Œæƒé™ç®¡ç†**ï¼ˆç”±Auth Serviceå’ŒAPI Gatewayè´Ÿè´£ï¼‰
- **ä¾›åº”å•†å‡­è¯çš„å­˜å‚¨å’Œç®¡ç†**ï¼ˆç”±Tenant Serviceç»Ÿä¸€ç®¡ç†ï¼‰
- **æ•°æ®åº“ç›´æ¥è®¿é—®**ï¼ˆé€šè¿‡HTTP APIè°ƒç”¨å…¶ä»–æœåŠ¡è·å–æ•°æ®ï¼‰
- **å¯¹è¯è®°å¿†çš„æŒä¹…åŒ–å­˜å‚¨**ï¼ˆç”±Memory Serviceè´Ÿè´£ï¼‰
- **ç§Ÿæˆ·å’Œç”¨æˆ·æ•°æ®ç®¡ç†**ï¼ˆç”±Tenant Serviceè´Ÿè´£ï¼‰

### ğŸ”— æœåŠ¡ä¾èµ–å…³ç³»
```
Frontend â†’ API Gateway â†’ EINO Service
                              â†“
                        Tenant Service (è·å–å‡­è¯)
                              â†“  
                         PostgreSQL (å‡­è¯å­˜å‚¨)
```

## ğŸ—ï¸ æŠ€æœ¯æ¶æ„

### ä¾èµ–å…³ç³»æ¾„æ¸…

**é‡è¦**: åŸºäºæœ€æ–°è°ƒç ”ï¼ŒEINOæ¡†æ¶é‡‡ç”¨"æŠ½è±¡ä¸å®ç°åˆ†ç¦»"çš„æ¶æ„æ¨¡å¼ï¼š

- **github.com/cloudwego/eino** (æ ¸å¿ƒåº“): æä¾›ç»„ä»¶æ¥å£æŠ½è±¡ã€ç¼–æ’å¼•æ“ã€ç±»å‹å®šä¹‰
- **github.com/cloudwego/eino-ext** (æ‰©å±•åº“): æä¾›å…·ä½“æ¨¡å‹å®ç°ï¼Œä¾èµ–äºæ ¸å¿ƒåº“

**æ ¸å¿ƒåº“å®Œå…¨ä¸ä¾èµ–æ‰©å±•åº“**ï¼Œè¿™ç§è®¾è®¡ç¡®ä¿æ ¸å¿ƒæ¡†æ¶ç¨³å®šï¼Œæ‰©å±•å®ç°å¯å¿«é€Ÿè¿­ä»£ã€‚

### æ­£ç¡®çš„ä¾èµ–å¯¼å…¥æ–¹å¼

```go
// æ­£ç¡®çš„å¯¼å…¥æ–¹å¼ - æŒ‰éœ€å¯¼å…¥å…·ä½“å®ç°
import (
    "context"
    
    // æ ¸å¿ƒæ¡†æ¶ - æä¾›æ¥å£å’Œç¼–æ’èƒ½åŠ›
    "github.com/cloudwego/eino"
    "github.com/cloudwego/eino/compose"
    "github.com/cloudwego/eino/schema"
    "github.com/cloudwego/eino/components/model"
    
    // å…·ä½“æ¨¡å‹å®ç° - æŒ‰éœ€å¯¼å…¥
    "github.com/cloudwego/eino-ext/components/model/openai"
    "github.com/cloudwego/eino-ext/components/model/ark"
    "github.com/cloudwego/eino-ext/components/model/deepseek"
    
    // å·¥å…·ç»„ä»¶å®ç°
    "github.com/cloudwego/eino-ext/components/tool/googlesearch"
)
```

### æ”¯æŒçš„AIä¾›åº”å•† (2025å¹´æœ€æ–°)

| ä¾›åº”å•† | EINO-EXTç»„ä»¶åŒ… | æ”¯æŒæ¨¡å‹ | çŠ¶æ€ |
|--------|------------|----------|------|
| **OpenAI** | `eino-ext/components/model/openai` | GPT-4o, GPT-4, GPT-3.5-turbo | âœ… å·²æ”¯æŒ |
| **DeepSeek** | `eino-ext/components/model/deepseek` | deepseek-chat, deepseek-reasoner | âœ… å·²æ”¯æŒ |
| **Volcengine Ark** | `eino-ext/components/model/ark` | è±†åŒ…å¤§æ¨¡å‹ç³»åˆ— | âœ… å·²æ”¯æŒ |
| **Volcengine ArkBot** | `eino-ext/components/model/arkbot` | ç«å±±å¼•æ“Botæ¨¡å‹ | âœ… å·²æ”¯æŒ |
| **Google Gemini** | `eino-ext/components/model/gemini` | Geminiç³»åˆ— | âœ… å·²æ”¯æŒ |
| **Anthropic Claude** | `eino-ext/components/model/anthropic` | Claudeç³»åˆ— | âœ… å·²æ”¯æŒ |
| **Ollama** | `eino-ext/components/model/ollama` | æœ¬åœ°éƒ¨ç½²æ¨¡å‹ | âœ… å·²æ”¯æŒ |

## ğŸ”§ æ ¸å¿ƒå·¥ä½œæµå®ç°

### 1. æ ‡å‡†èŠå¤©å·¥ä½œæµ (åŸºäºEINO Chain API)

åŸºäºæœ€æ–°EINOæ¡†æ¶çš„æ­£ç¡®å®ç°æ–¹å¼ï¼š

```go
// æ ‡å‡†èŠå¤©å·¥ä½œæµå®ç°
type StandardChatWorkflow struct {
    credentialManager *CredentialManager
    logger           *logrus.Logger
}

// æ ¹æ®ä¾›åº”å•†åˆ›å»ºå¯¹åº”çš„ChatModel
func (w *StandardChatWorkflow) createChatModel(ctx context.Context, credential *SupplierCredential) (model.ChatModel, error) {
    switch credential.Provider {
    case "openai":
        return openai.NewChatModel(ctx, &openai.ChatModelConfig{
            APIKey:      credential.APIKey,
            Model:       credential.ModelConfigs["model"].(string),
            BaseURL:     credential.BaseURL,
            Temperature: credential.ModelConfigs["temperature"].(*float32),
            MaxTokens:   credential.ModelConfigs["max_tokens"].(*int),
        })
    case "deepseek":
        return deepseek.NewChatModel(ctx, &deepseek.ChatModelConfig{
            APIKey:      credential.APIKey,
            Model:       credential.ModelConfigs["model"].(string),
            Temperature: credential.ModelConfigs["temperature"].(float32),
            MaxTokens:   credential.ModelConfigs["max_tokens"].(int),
        })
    case "ark":
        return ark.NewChatModel(ctx, &ark.ChatModelConfig{
            APIKey:    credential.APIKey,
            Model:     credential.ModelConfigs["model"].(string),
            Region:    credential.ModelConfigs["region"].(string),
            BaseURL:   credential.BaseURL,
        })
    default:
        return nil, fmt.Errorf("ä¸æ”¯æŒçš„ä¾›åº”å•†: %s", credential.Provider)
    }
}

// ä½¿ç”¨EINO Chainæ„å»ºç®€å•èŠå¤©å·¥ä½œæµ
func (w *StandardChatWorkflow) buildChatChain(ctx context.Context, credential *SupplierCredential) (compose.Runnable[*schema.Message, *schema.Message], error) {
    // åˆ›å»ºèŠå¤©æ¨¡å‹
    chatModel, err := w.createChatModel(ctx, credential)
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»ºèŠå¤©æ¨¡å‹å¤±è´¥: %w", err)
    }
    
    // æ„å»ºChain - æœ€ç®€å•çš„æƒ…å†µï¼Œç›´æ¥ä½¿ç”¨ChatModel
    chain := compose.NewChain[*schema.Message, *schema.Message]().
        AppendChatModel(chatModel)
    
    // ç¼–è¯‘Chain
    compiled, err := chain.Compile(ctx)
    if err != nil {
        return nil, fmt.Errorf("ç¼–è¯‘èŠå¤©é“¾å¤±è´¥: %w", err)
    }
    
    return compiled, nil
}

// æ ‡å‡†èŠå¤©å·¥ä½œæµæ‰§è¡Œ
func (w *StandardChatWorkflow) Execute(ctx context.Context, req *WorkflowRequest) (*WorkflowResponse, error) {
    startTime := time.Now()
    
    // 1. è·å–ç§Ÿæˆ·æœ€ä½³å‡­è¯
    credential, err := w.credentialManager.GetBestCredential(req.TenantID, req.ModelConfig["provider"].(string))
    if err != nil {
        return nil, fmt.Errorf("è·å–å‡­è¯å¤±è´¥: %w", err)
    }
    
    // 2. æ„å»ºEINOå·¥ä½œæµé“¾
    runnable, err := w.buildChatChain(ctx, credential)
    if err != nil {
        return nil, fmt.Errorf("æ„å»ºå·¥ä½œæµé“¾å¤±è´¥: %w", err)
    }
    
    // 3. æ„å»ºè¾“å…¥æ¶ˆæ¯
    inputMessage := &schema.Message{
        Role:    schema.User,
        Content: req.Message,
    }
    
    // 4. æ‰§è¡ŒEINOé“¾ - æ³¨æ„æœ€æ–°çš„APIè°ƒç”¨æ–¹å¼
    result, err := runnable.Invoke(ctx, inputMessage)
    if err != nil {
        return nil, fmt.Errorf("EINOé“¾æ‰§è¡Œå¤±è´¥: %w", err)
    }
    
    // 5. è®°å½•å‡­è¯ä½¿ç”¨
    w.credentialManager.RecordUsage(credential.ID)
    
    // 6. æ„å»ºå“åº”
    response := &WorkflowResponse{
        Success:         true,
        Content:         result.Content,
        Model:           credential.ModelConfigs["model"].(string),
        WorkflowType:    "standard_chat",
        ExecutionTimeMs: time.Since(startTime).Milliseconds(),
        Metadata: map[string]interface{}{
            "provider":      credential.Provider,
            "credential_id": credential.ID,
            "model_used":    credential.ModelConfigs["model"],
        },
    }
    
    // 7. æå–Tokenä½¿ç”¨ä¿¡æ¯ï¼ˆå¦‚æœå¯ç”¨ï¼‰
    if result.ResponseMeta != nil && result.ResponseMeta.Usage != nil {
        response.Usage = &TokenUsage{
            PromptTokens:     int(result.ResponseMeta.Usage.PromptTokens),
            CompletionTokens: int(result.ResponseMeta.Usage.CompletionTokens),
            TotalTokens:      int(result.ResponseMeta.Usage.TotalTokens),
        }
    }
    
    return response, nil
}
```

### 2. æµå¼èŠå¤©å·¥ä½œæµ (åŸºäºEINO Stream API)

```go
// æµå¼èŠå¤©å·¥ä½œæµæ‰§è¡Œ
func (w *StandardChatWorkflow) ExecuteStream(ctx context.Context, req *WorkflowRequest) (<-chan *WorkflowStreamResponse, error) {
    responseChan := make(chan *WorkflowStreamResponse, 100)
    
    go func() {
        defer close(responseChan)
        
        // 1. è·å–ç§Ÿæˆ·æœ€ä½³å‡­è¯
        credential, err := w.credentialManager.GetBestCredential(req.TenantID, req.ModelConfig["provider"].(string))
        if err != nil {
            responseChan <- &WorkflowStreamResponse{
                Type:  "error",
                Error: fmt.Sprintf("è·å–å‡­è¯å¤±è´¥: %v", err),
            }
            return
        }
        
        // 2. æ„å»ºEINOå·¥ä½œæµé“¾
        runnable, err := w.buildChatChain(ctx, credential)
        if err != nil {
            responseChan <- &WorkflowStreamResponse{
                Type:  "error",
                Error: fmt.Sprintf("æ„å»ºå·¥ä½œæµé“¾å¤±è´¥: %v", err),
            }
            return
        }
        
        // 3. æ„å»ºè¾“å…¥æ¶ˆæ¯
        inputMessage := &schema.Message{
            Role:    schema.User,
            Content: req.Message,
        }
        
        // 4. å‘é€å¼€å§‹äº‹ä»¶
        responseChan <- &WorkflowStreamResponse{
            Type:        "start",
            ExecutionID: req.ExecutionID,
            Data:        map[string]any{"provider": credential.Provider},
        }
        
        // 5. æ‰§è¡Œæµå¼è°ƒç”¨ - ä½¿ç”¨EINOçš„Streamæ–¹æ³•
        streamReader, err := runnable.Stream(ctx, inputMessage)
        if err != nil {
            responseChan <- &WorkflowStreamResponse{
                Type:  "error",
                Error: fmt.Sprintf("æµå¼è°ƒç”¨å¤±è´¥: %v", err),
            }
            return
        }
        defer streamReader.Close()
        
        // 6. å¤„ç†æµå¼å“åº”
        var fullContent string
        for {
            chunk, err := streamReader.Recv()
            if err == io.EOF {
                break
            }
            if err != nil {
                responseChan <- &WorkflowStreamResponse{
                    Type:  "error", 
                    Error: fmt.Sprintf("æ¥æ”¶æµå¼æ•°æ®å¤±è´¥: %v", err),
                }
                return
            }
            
            fullContent += chunk.Content
            responseChan <- &WorkflowStreamResponse{
                Type:        "chunk",
                ExecutionID: req.ExecutionID,
                Content:     chunk.Content, // å‘é€å¢é‡å†…å®¹
                Data: map[string]any{
                    "accumulated_content": fullContent,
                    "delta":              chunk.Content,
                },
            }
        }
        
        // 7. å‘é€ç»“æŸäº‹ä»¶
        responseChan <- &WorkflowStreamResponse{
            Type:        "end",
            ExecutionID: req.ExecutionID,
            Content:     fullContent,
            Data: map[string]any{
                "final_content": fullContent,
                "provider":      credential.Provider,
            },
        }
        
        // 8. è®°å½•å‡­è¯ä½¿ç”¨
        w.credentialManager.RecordUsage(credential.ID)
    }()
    
    return responseChan, nil
}
```

## ğŸ” æ™ºèƒ½å‡­è¯ç®¡ç†ç³»ç»Ÿ

### æ¶æ„è®¾è®¡åŸåˆ™

**é‡è¦æé†’**: EINO Serviceé‡‡ç”¨**æ— çŠ¶æ€ + ç¼“å­˜ä¼˜åŒ–**çš„æ¶æ„æ¨¡å¼ï¼š

1. **ä¸ç›´æ¥è®¿é—®æ•°æ®åº“** - æ‰€æœ‰å‡­è¯æ•°æ®é€šè¿‡Tenant Service HTTP APIè·å–
2. **æ™ºèƒ½æœ¬åœ°ç¼“å­˜** - å‡å°‘ç½‘ç»œè°ƒç”¨ï¼Œæå‡å“åº”æ€§èƒ½
3. **æ•…éšœå®¹é”™æœºåˆ¶** - ç¼“å­˜å¤±æ•ˆæ—¶è‡ªåŠ¨å›é€€åˆ°APIè°ƒç”¨
4. **ç§Ÿæˆ·çº§åˆ«éš”ç¦»** - ç¼“å­˜KeyåŒ…å«tenant_idï¼Œç¡®ä¿å¤šç§Ÿæˆ·å®‰å…¨

### å‡­è¯ç®¡ç†å™¨æ¶æ„

```go
// æ™ºèƒ½å‡­è¯ç®¡ç†å™¨ - ä¸“æ³¨äºç¼“å­˜å’Œé€‰æ‹©ç®—æ³•
type CredentialManager struct {
    tenantClient   *TenantServiceClient   // ç§Ÿæˆ·æœåŠ¡HTTPå®¢æˆ·ç«¯
    redisClient    *redis.Client          // Redisç¼“å­˜å®¢æˆ·ç«¯  
    cache          map[string]*SupplierCredential // æœ¬åœ°L1ç¼“å­˜
    lastUsed       map[string]time.Time   // æœ€åä½¿ç”¨æ—¶é—´
    usage          map[string]int64       // ä½¿ç”¨æ¬¡æ•°ç»Ÿè®¡
    healthStatus   map[string]bool        // å¥åº·çŠ¶æ€ç›‘æ§
    mutex          sync.RWMutex           // è¯»å†™é”
    logger         *logrus.Logger         // æ—¥å¿—è®°å½•å™¨
}

// ä¾›åº”å•†å‡­è¯ç»“æ„ï¼ˆä»Tenant Serviceè·å–ï¼‰
type SupplierCredential struct {
    ID           string                 `json:"id"`
    TenantID     string                 `json:"tenant_id"`
    Provider     string                 `json:"provider_name"`    // openai, deepseek, arkç­‰
    DisplayName  string                 `json:"display_name"`
    APIKey       string                 `json:"api_key"`
    BaseURL      string                 `json:"base_url"`
    ModelConfigs map[string]interface{} `json:"model_configs"`
    IsActive     bool                   `json:"is_active"`
    CreatedAt    time.Time              `json:"created_at"`
    UpdatedAt    time.Time              `json:"updated_at"`
}

// æ™ºèƒ½å‡­è¯è·å–ç®—æ³• - ä¸‰çº§ç¼“å­˜ç­–ç•¥
func (cm *CredentialManager) GetBestCredential(tenantID, provider string) (*SupplierCredential, error) {
    cacheKey := fmt.Sprintf("tenant:%s:credentials:%s", tenantID, provider)
    
    // 1. æ£€æŸ¥æœ¬åœ°ç¼“å­˜ (L1)
    cm.mutex.RLock()
    if cached, exists := cm.cache[cacheKey]; exists {
        if time.Since(cached.UpdatedAt) < 2*time.Minute && cm.healthStatus[cached.ID] {
            cm.mutex.RUnlock()
            cm.logger.WithFields(logrus.Fields{
                "tenant_id":     tenantID,
                "provider":      provider,
                "credential_id": cached.ID,
                "source":        "local_cache",
            }).Debug("ä½¿ç”¨æœ¬åœ°ç¼“å­˜çš„å‡­è¯")
            return cached, nil
        }
    }
    cm.mutex.RUnlock()
    
    // 2. æ£€æŸ¥Redisç¼“å­˜ (L2)
    if cm.redisClient != nil {
        ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
        defer cancel()
        
        if credentialJSON, err := cm.redisClient.Get(ctx, cacheKey).Result(); err == nil {
            var credential SupplierCredential
            if json.Unmarshal([]byte(credentialJSON), &credential) == nil {
                if time.Since(credential.UpdatedAt) < 5*time.Minute {
                    cm.updateLocalCache(cacheKey, &credential)
                    cm.logger.WithFields(logrus.Fields{
                        "tenant_id":     tenantID,
                        "provider":      provider,
                        "credential_id": credential.ID,
                        "source":        "redis_cache",
                    }).Debug("ä½¿ç”¨Redisç¼“å­˜çš„å‡­è¯")
                    return &credential, nil
                }
            }
        }
    }
    
    // 3. ä»Tenant Serviceè·å–æœ€æ–°å‡­è¯ (L3 - APIè°ƒç”¨)
    credentials, err := cm.tenantClient.GetAvailableCredentials(tenantID, &CredentialSelector{
        Strategy: "least_used",
        Filters: struct {
            OnlyActive bool     `json:"only_active"`
            Providers  []string `json:"providers"`
        }{
            OnlyActive: true,
            Providers:  []string{provider},
        },
    })
    
    if err != nil {
        return nil, fmt.Errorf("ä»Tenant Serviceè·å–å‡­è¯å¤±è´¥: %w", err)
    }
    
    if len(credentials) == 0 {
        return nil, fmt.Errorf("ç§Ÿæˆ· %s æ²¡æœ‰å¯ç”¨çš„ %s å‡­è¯", tenantID, provider)
    }
    
    // 4. æ™ºèƒ½é€‰æ‹©æœ€ä½³å‡­è¯
    best := cm.selectBestCredential(credentials)
    
    // 5. æ›´æ–°å¤šçº§ç¼“å­˜
    cm.updateCaches(cacheKey, best)
    
    cm.logger.WithFields(logrus.Fields{
        "tenant_id":     tenantID,
        "provider":      provider,
        "credential_id": best.ID,
        "source":        "tenant_service_api",
    }).Info("ä»Tenant Serviceè·å–æ–°å‡­è¯")
    
    return best, nil
}

// å‡­è¯è¯„åˆ†ç®—æ³•
func (cm *CredentialManager) selectBestCredential(credentials []*SupplierCredential) *SupplierCredential {
    var best *SupplierCredential
    var bestScore float64
    
    for _, cred := range credentials {
        score := 100.0
        
        // å¥åº·çŠ¶æ€æƒé‡ (50%)
        if !cm.healthStatus[cred.ID] {
            score -= 50
        }
        
        // è´Ÿè½½å‡è¡¡æƒé‡ (30%)
        usageCount := cm.usage[cred.ID]
        score -= float64(usageCount) * 0.1
        
        // æœ€è¿‘ä½¿ç”¨æ—¶é—´æƒé‡ (20%)
        if lastUsed, exists := cm.lastUsed[cred.ID]; exists {
            minutesSinceUsed := time.Since(lastUsed).Minutes()
            if minutesSinceUsed > 30 {
                score -= minutesSinceUsed * 0.1
            }
        }
        
        if best == nil || score > bestScore {
            best = cred
            bestScore = score
        }
    }
    
    return best
}
```

### å‡­è¯å¥åº·æ£€æŸ¥ç³»ç»Ÿ

```go
// å¯åŠ¨å¥åº·æ£€æŸ¥æœåŠ¡
func (cm *CredentialManager) StartHealthCheck(ctx context.Context) {
    ticker := time.NewTicker(2 * time.Minute)
    defer ticker.Stop()
    
    cm.logger.Info("å¯åŠ¨å‡­è¯å¥åº·æ£€æŸ¥æœåŠ¡")
    
    for {
        select {
        case <-ctx.Done():
            cm.logger.Info("å‡­è¯å¥åº·æ£€æŸ¥æœåŠ¡åœæ­¢")
            return
        case <-ticker.C:
            cm.performHealthCheck(ctx)
        }
    }
}

// æ‰§è¡Œå¥åº·æ£€æŸ¥
func (cm *CredentialManager) performHealthCheck(ctx context.Context) {
    cm.mutex.RLock()
    credentials := make([]*SupplierCredential, 0, len(cm.cache))
    for _, cred := range cm.cache {
        credentials = append(credentials, cred)
    }
    cm.mutex.RUnlock()
    
    var wg sync.WaitGroup
    for _, cred := range credentials {
        wg.Add(1)
        go func(c *SupplierCredential) {
            defer wg.Done()
            cm.checkSingleCredential(ctx, c)
        }(cred)
    }
    wg.Wait()
    
    cm.logger.WithField("checked_count", len(credentials)).Info("å‡­è¯å¥åº·æ£€æŸ¥å®Œæˆ")
}

// å•ä¸ªå‡­è¯å¥åº·æ£€æŸ¥
func (cm *CredentialManager) checkSingleCredential(ctx context.Context, cred *SupplierCredential) {
    startTime := time.Now()
    
    // ä½¿ç”¨å¯¹åº”çš„EINOæ¨¡å‹ç»„ä»¶è¿›è¡Œå¥åº·æ£€æŸ¥
    healthy := false
    
    switch cred.Provider {
    case "openai":
        healthy = cm.checkOpenAICredential(ctx, cred)
    case "deepseek":
        healthy = cm.checkDeepSeekCredential(ctx, cred)
    case "ark":
        healthy = cm.checkArkCredential(ctx, cred)
    default:
        cm.logger.WithField("provider", cred.Provider).Warn("ä¸æ”¯æŒçš„ä¾›åº”å•†å¥åº·æ£€æŸ¥")
        healthy = false
    }
    
    // æ›´æ–°å¥åº·çŠ¶æ€
    cm.mutex.Lock()
    cm.healthStatus[cred.ID] = healthy
    cm.mutex.Unlock()
    
    duration := time.Since(startTime)
    cm.logger.WithFields(logrus.Fields{
        "credential_id": cred.ID,
        "provider":      cred.Provider,
        "display_name":  cred.DisplayName,
        "healthy":       healthy,
        "duration_ms":   duration.Milliseconds(),
    }).Info("å‡­è¯å¥åº·æ£€æŸ¥å®Œæˆ")
}

// OpenAIå‡­è¯å¥åº·æ£€æŸ¥
func (cm *CredentialManager) checkOpenAICredential(ctx context.Context, cred *SupplierCredential) bool {
    model, err := openai.NewChatModel(ctx, &openai.ChatModelConfig{
        APIKey:  cred.APIKey,
        Model:   "gpt-3.5-turbo", // ä½¿ç”¨æœ€ä¾¿å®œçš„æ¨¡å‹è¿›è¡Œæµ‹è¯•
        BaseURL: cred.BaseURL,
    })
    
    if err != nil {
        cm.logger.WithError(err).WithField("credential_id", cred.ID).Error("åˆ›å»ºOpenAIæ¨¡å‹å¤±è´¥")
        return false
    }
    
    // å‘é€ç®€å•æµ‹è¯•æ¶ˆæ¯
    testCtx, cancel := context.WithTimeout(ctx, 10*time.Second)
    defer cancel()
    
    messages := []*schema.Message{
        {
            Role:    schema.User,
            Content: "ping",
        },
    }
    
    _, err = model.Generate(testCtx, messages)
    return err == nil
}

// DeepSeekå‡­è¯å¥åº·æ£€æŸ¥
func (cm *CredentialManager) checkDeepSeekCredential(ctx context.Context, cred *SupplierCredential) bool {
    model, err := deepseek.NewChatModel(ctx, &deepseek.ChatModelConfig{
        APIKey: cred.APIKey,
        Model:  "deepseek-chat",
    })
    
    if err != nil {
        cm.logger.WithError(err).WithField("credential_id", cred.ID).Error("åˆ›å»ºDeepSeekæ¨¡å‹å¤±è´¥")
        return false
    }
    
    testCtx, cancel := context.WithTimeout(ctx, 10*time.Second)
    defer cancel()
    
    messages := []*schema.Message{
        {
            Role:    schema.User,
            Content: "ping",
        },
    }
    
    _, err = model.Generate(testCtx, messages)
    return err == nil
}
```

## ğŸ“¡ å¯¹å¤–APIæ¥å£

### 1. æ ‡å‡†èŠå¤©æ¥å£

```http
POST /api/v1/chat/completions
Content-Type: application/json
Authorization: Bearer {jwt_token}
X-Tenant-ID: {tenant_id}
```

**è¯·æ±‚ä½“:**
```json
{
  "model": "gpt-4",
  "messages": [
    {
      "role": "system",
      "content": "ä½ æ˜¯ä¸€ä¸ªæœ‰ç”¨çš„AIåŠ©æ‰‹"
    },
    {
      "role": "user", 
      "content": "è¯·è§£é‡Šä¸€ä¸‹æœºå™¨å­¦ä¹ çš„åŸºæœ¬æ¦‚å¿µ"
    }
  ],
  "temperature": 0.7,
  "max_tokens": 2048,
  "stream": false,
  "provider": "openai"
}
```

**å“åº”:**
```json
{
  "success": true,
  "data": {
    "id": "chatcmpl-uuid",
    "object": "chat.completion",
    "created": 1710845760,
    "model": "gpt-4",
    "choices": [
      {
        "index": 0,
        "message": {
          "role": "assistant",
          "content": "æœºå™¨å­¦ä¹ æ˜¯äººå·¥æ™ºèƒ½çš„ä¸€ä¸ªåˆ†æ”¯..."
        },
        "finish_reason": "stop"
      }
    ],
    "usage": {
      "prompt_tokens": 45,
      "completion_tokens": 312,
      "total_tokens": 357
    },
    "provider": "openai",
    "execution_time_ms": 1250
  },
  "request_id": "req-20250717-uuid",
  "timestamp": "2025-07-17T14:30:00Z"
}
```

### 2. æµå¼èŠå¤©æ¥å£

```http
POST /api/v1/chat/completions
Content-Type: application/json
Authorization: Bearer {jwt_token}
X-Tenant-ID: {tenant_id}
```

**è¯·æ±‚ä½“:**
```json
{
  "model": "gpt-4",
  "messages": [
    {
      "role": "user",
      "content": "å†™ä¸€é¦–å…³äºæ˜¥å¤©çš„è¯—"
    }
  ],
  "stream": true,
  "provider": "openai"
}
```

**æµå¼å“åº” (Server-Sent Events):**
```
data: {"id":"chatcmpl-uuid","object":"chat.completion.chunk","created":1710845760,"model":"gpt-4","choices":[{"index":0,"delta":{"role":"assistant","content":""},"finish_reason":null}]}

data: {"id":"chatcmpl-uuid","object":"chat.completion.chunk","created":1710845760,"model":"gpt-4","choices":[{"index":0,"delta":{"content":"æ˜¥"},"finish_reason":null}]}

data: {"id":"chatcmpl-uuid","object":"chat.completion.chunk","created":1710845760,"model":"gpt-4","choices":[{"index":0,"delta":{"content":"å¤©"},"finish_reason":null}]}

data: {"id":"chatcmpl-uuid","object":"chat.completion.chunk","created":1710845760,"model":"gpt-4","choices":[{"index":0,"delta":{"content":"çš„"},"finish_reason":null}]}

data: [DONE]
```

### 3. æ¨¡å‹åˆ—è¡¨æ¥å£

```http
GET /api/v1/models
Authorization: Bearer {jwt_token}
X-Tenant-ID: {tenant_id}
```

**å“åº”:**
```json
{
  "success": true,
  "data": {
    "object": "list",
    "data": [
      {
        "id": "gpt-4",
        "object": "model",
        "provider": "openai",
        "available": true,
        "credentials_count": 2
      },
      {
        "id": "claude-3-sonnet",
        "object": "model", 
        "provider": "anthropic",
        "available": false,
        "credentials_count": 0
      },
      {
        "id": "deepseek-chat",
        "object": "model",
        "provider": "deepseek", 
        "available": true,
        "credentials_count": 1
      }
    ]
  }
}
```

## ğŸ”— ä¸Tenant Serviceé›†æˆ

### æœåŠ¡é—´é€šä¿¡åè®®

**EINO Serviceä¸Tenant Serviceä¹‹é—´é‡‡ç”¨HTTP RESTful APIé€šä¿¡**ï¼Œéµå¾ªå¾®æœåŠ¡æ¶æ„æœ€ä½³å®è·µï¼š

1. **æ— çŠ¶æ€é€šä¿¡** - æ¯æ¬¡è¯·æ±‚åŒ…å«å®Œæ•´ä¸Šä¸‹æ–‡ä¿¡æ¯
2. **æ ‡å‡†HTTPçŠ¶æ€ç ** - 200æˆåŠŸã€404æœªæ‰¾åˆ°ã€500æœåŠ¡é”™è¯¯ç­‰
3. **JSONæ•°æ®æ ¼å¼** - ç»Ÿä¸€ä½¿ç”¨JSONè¿›è¡Œæ•°æ®äº¤æ¢
4. **è¶…æ—¶å’Œé‡è¯•** - é…ç½®åˆç†çš„è¶…æ—¶æ—¶é—´å’Œé‡è¯•ç­–ç•¥
5. **é”™è¯¯å¤„ç†** - ä¼˜é›…å¤„ç†ç½‘ç»œå¼‚å¸¸å’ŒæœåŠ¡ä¸å¯ç”¨æƒ…å†µ

### Tenant Serviceå†…éƒ¨APIæ¥å£

**ä»¥ä¸‹æ¥å£ç”±Tenant Serviceæä¾›ï¼Œä¾›EINO Serviceè°ƒç”¨ï¼š**

#### 1. è·å–å¯ç”¨å‡­è¯åˆ—è¡¨
```http
GET /internal/suppliers/{tenant_id}/available
Authorization: Internal-Service-Token
Query Parameters:
  - strategy: least_used | round_robin | first_available
  - only_active: true | false
  - providers: openai,deepseek,ark (é€—å·åˆ†éš”)

Response:
{
  "success": true,
  "data": [
    {
      "id": "credential-uuid",
      "provider": "openai", 
      "api_key": "sk-...",  // å·²è§£å¯†
      "model_configs": {...},
      "is_active": true,
      "usage_stats": {...}
    }
  ]
}
```

#### 2. å‡­è¯å¥åº·æ£€æµ‹
```http
POST /internal/suppliers/{credential_id}/health-check
Authorization: Internal-Service-Token
Content-Type: application/json

{
  "tenant_id": "tenant-uuid",
  "test_type": "connection",
  "model_name": "gpt-3.5-turbo"
}

Response:
{
  "success": true,
  "data": {
    "healthy": true,
    "response_time_ms": 350,
    "last_checked": "2025-07-18T10:30:00Z",
    "error_message": null
  }
}
```

#### 3. æ›´æ–°å‡­è¯ä½¿ç”¨ç»Ÿè®¡
```http
POST /internal/suppliers/{credential_id}/usage
Authorization: Internal-Service-Token
Content-Type: application/json

{
  "tenant_id": "tenant-uuid",
  "tokens_used": 1500,
  "request_count": 1,
  "execution_time_ms": 1200
}
```

### Tenant Serviceå®¢æˆ·ç«¯å®ç°

**åŸºäºå¾®æœåŠ¡æ¶æ„çš„HTTPå®¢æˆ·ç«¯è®¾è®¡**ï¼š

```go
type TenantServiceClient struct {
    baseURL     string
    client      *http.Client
    logger      *logrus.Logger
    authToken   string  // å†…éƒ¨æœåŠ¡è®¤è¯ä»¤ç‰Œ
    timeout     time.Duration
    retryConfig *RetryConfig
}

type RetryConfig struct {
    MaxRetries int
    BackoffMs  []int  // é€’å¢é€€é¿ç­–ç•¥
}

// è·å–ç§Ÿæˆ·å¯ç”¨å‡­è¯ - æ ¸å¿ƒæ¥å£
func (c *TenantServiceClient) GetAvailableCredentials(tenantID string, selector *CredentialSelector) ([]*SupplierCredential, error) {
    url := fmt.Sprintf("%s/internal/suppliers/%s/available", c.baseURL, tenantID)
    
    req, err := http.NewRequest("GET", url, nil)
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»ºHTTPè¯·æ±‚å¤±è´¥: %w", err)
    }
    
    // æ·»åŠ å†…éƒ¨æœåŠ¡è®¤è¯å¤´
    req.Header.Set("Authorization", fmt.Sprintf("Internal-Service-Token %s", c.authToken))
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("X-Service-Name", "eino-service")
    
    // æ„å»ºæŸ¥è¯¢å‚æ•°
    q := req.URL.Query()
    if selector != nil {
        q.Add("strategy", selector.Strategy)
        q.Add("only_active", fmt.Sprintf("%t", selector.Filters.OnlyActive))
        if len(selector.Filters.Providers) > 0 {
            q.Add("providers", strings.Join(selector.Filters.Providers, ","))
        }
    }
    req.URL.RawQuery = q.Encode()
    
    // æ‰§è¡Œè¯·æ±‚ï¼ˆå¸¦é‡è¯•æœºåˆ¶ï¼‰
    resp, err := c.executeWithRetry(req)
    if err != nil {
        return nil, fmt.Errorf("è°ƒç”¨Tenant Serviceå¤±è´¥: %w", err)
    }
    defer resp.Body.Close()
    
    // è§£æå“åº”
    var result struct {
        Success bool                  `json:"success"`
        Data    []*SupplierCredential `json:"data"`
        Message string                `json:"message"`
        RequestID string              `json:"request_id"`
    }
    
    if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
        return nil, fmt.Errorf("è§£æTenant Serviceå“åº”å¤±è´¥: %w", err)
    }
    
    if !result.Success {
        return nil, fmt.Errorf("Tenant Serviceè¿”å›é”™è¯¯: %s", result.Message)
    }
    
    c.logger.WithFields(logrus.Fields{
        "tenant_id":         tenantID,
        "credentials_count": len(result.Data),
        "request_id":        result.RequestID,
        "source":           "tenant_service",
    }).Info("æˆåŠŸè·å–ç§Ÿæˆ·å‡­è¯")
    
    return result.Data, nil
}

// HTTPè¯·æ±‚é‡è¯•æœºåˆ¶
func (c *TenantServiceClient) executeWithRetry(req *http.Request) (*http.Response, error) {
    var lastErr error
    
    for i := 0; i <= c.retryConfig.MaxRetries; i++ {
        if i > 0 {
            // æŒ‡æ•°é€€é¿ç­–ç•¥
            backoffMs := c.retryConfig.BackoffMs[min(i-1, len(c.retryConfig.BackoffMs)-1)]
            time.Sleep(time.Duration(backoffMs) * time.Millisecond)
            c.logger.WithField("retry_attempt", i).Warn("é‡è¯•è°ƒç”¨Tenant Service")
        }
        
        ctx, cancel := context.WithTimeout(context.Background(), c.timeout)
        reqWithTimeout := req.WithContext(ctx)
        
        resp, err := c.client.Do(reqWithTimeout)
        cancel()
        
        if err == nil && resp.StatusCode < 500 {
            return resp, nil  // æˆåŠŸæˆ–å®¢æˆ·ç«¯é”™è¯¯ï¼Œä¸é‡è¯•
        }
        
        if err != nil {
            lastErr = err
        } else {
            lastErr = fmt.Errorf("HTTP %d", resp.StatusCode)
            resp.Body.Close()
        }
    }
    
    return nil, fmt.Errorf("é‡è¯•%dæ¬¡åä»å¤±è´¥: %w", c.retryConfig.MaxRetries, lastErr)
}

// æµ‹è¯•å‡­è¯è¿æ¥æ€§
func (c *TenantServiceClient) TestCredential(credentialID, tenantID, modelName string) (bool, error) {
    url := fmt.Sprintf("%s/internal/suppliers/%s/test", c.baseURL, credentialID)
    
    reqBody := map[string]interface{}{
        "tenant_id":  tenantID,
        "test_type":  "connection",
        "model_name": modelName,
    }
    
    bodyBytes, err := json.Marshal(reqBody)
    if err != nil {
        return false, fmt.Errorf("ç¼–ç è¯·æ±‚ä½“å¤±è´¥: %w", err)
    }
    
    resp, err := c.client.Post(url, "application/json", bytes.NewBuffer(bodyBytes))
    if err != nil {
        return false, fmt.Errorf("æµ‹è¯•å‡­è¯è¯·æ±‚å¤±è´¥: %w", err)
    }
    defer resp.Body.Close()
    
    var result struct {
        Success bool `json:"success"`
        Data    struct {
            Success        bool `json:"success"`
            ResponseTimeMs int  `json:"response_time_ms"`
        } `json:"data"`
        Message string `json:"message"`
    }
    
    if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
        return false, fmt.Errorf("è§£ææµ‹è¯•ç»“æœå¤±è´¥: %w", err)
    }
    
    return result.Success && result.Data.Success, nil
}
```

## ğŸš€ éƒ¨ç½²å’Œè¿è¡Œ

### Goæ¨¡å—é…ç½® (go.mod)

åŸºäºæœ€æ–°EINOæ¡†æ¶çš„æ­£ç¡®ä¾èµ–é…ç½®ï¼š

```go
module eino-service

go 1.21

require (
    // EINOæ ¸å¿ƒæ¡†æ¶
    github.com/cloudwego/eino v0.3.34
    
    // å…·ä½“æ¨¡å‹å®ç° - æŒ‰éœ€å¯¼å…¥
    github.com/cloudwego/eino-ext/components/model/openai v0.3.34
    github.com/cloudwego/eino-ext/components/model/deepseek v0.3.34
    github.com/cloudwego/eino-ext/components/model/ark v0.3.34
    github.com/cloudwego/eino-ext/components/model/arkbot v0.3.34
    github.com/cloudwego/eino-ext/components/model/gemini v0.3.34
    
    // å·¥å…·ç»„ä»¶
    github.com/cloudwego/eino-ext/components/tool/googlesearch v0.3.34
    
    // å…¶ä»–ä¾èµ–
    github.com/gin-gonic/gin v1.9.1
    github.com/sirupsen/logrus v1.9.3
    github.com/redis/go-redis/v9 v9.0.5
)
```

### ç¯å¢ƒå˜é‡é…ç½®

```bash
# æœåŠ¡åŸºæœ¬é…ç½®
PORT=8003
LOG_LEVEL=INFO
GIN_MODE=release

# Redisé…ç½® (ç”¨äºå‡­è¯å’Œå“åº”ç¼“å­˜)
REDIS_HOST=localhost
REDIS_PORT=6380
REDIS_PASSWORD=

# ä¾èµ–æœåŠ¡ - EINO Serviceé€šè¿‡HTTP APIè°ƒç”¨å…¶ä»–æœåŠ¡
TENANT_SERVICE_URL=http://localhost:8002
MEMORY_SERVICE_URL=http://localhost:8004

# æ³¨æ„: EINO Serviceä¸ç›´æ¥è¿æ¥PostgreSQLæ•°æ®åº“
# æ‰€æœ‰æ•°æ®é€šè¿‡Tenant Serviceçš„HTTP APIè·å–

# EINOæ¡†æ¶é…ç½®
EINO_COMPILE_TIMEOUT=10s
EINO_EXECUTION_TIMEOUT=60s
CREDENTIAL_CACHE_TTL=300s
HEALTH_CHECK_INTERVAL=120s

# AIæ¨¡å‹é»˜è®¤é…ç½®
DEFAULT_REQUEST_TIMEOUT=30s
MAX_TOKENS_PER_REQUEST=8192
DEFAULT_TEMPERATURE=0.7
```

### Dockeré…ç½®

```dockerfile
FROM golang:1.21-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o eino-service ./cmd/server

FROM alpine:latest
RUN apk --no-cache add ca-certificates tzdata
WORKDIR /root/

COPY --from=builder /app/eino-service .

EXPOSE 8003
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost:8003/health || exit 1

CMD ["./eino-service"]
```

### ç¼–è¯‘å’Œå¯åŠ¨

```bash
# ä¸‹è½½EINOä¾èµ–
go mod download

# ç¼–è¯‘æœåŠ¡
go build -o bin/eino-service ./cmd/server

# å¯åŠ¨æœåŠ¡
./bin/eino-service

# æˆ–è€…ç›´æ¥è¿è¡Œ
go run ./cmd/server

# éªŒè¯EINOæ¡†æ¶ç‰ˆæœ¬
go list -m github.com/cloudwego/eino
```

### å¥åº·æ£€æŸ¥

```http
GET /health
```

**å“åº”:**
```json
{
  "status": "healthy",
  "timestamp": "2025-07-17T14:30:00Z",
  "version": "1.0.0",
  "dependencies": {
    "tenant_service": "healthy",
    "database": "healthy",
    "redis": "healthy"
  },
  "metrics": {
    "cached_credentials": 15,
    "healthy_credentials": 12,
    "active_executions": 3
  }
}
```

## ğŸ“Š ç›‘æ§å’Œæ—¥å¿—

### å…³é”®æŒ‡æ ‡

- **æ¨¡å‹è°ƒç”¨æˆåŠŸç‡**: æŒ‰ä¾›åº”å•†å’Œæ¨¡å‹åˆ†ç»„
- **å“åº”å»¶è¿Ÿåˆ†å¸ƒ**: P50, P95, P99å»¶è¿Ÿç»Ÿè®¡  
- **å‡­è¯å¥åº·çŠ¶æ€**: å¯ç”¨å‡­è¯æ•°é‡å’Œå¥åº·æ¯”ä¾‹
- **å¹¶å‘æ‰§è¡Œæ•°**: å½“å‰æ´»è·ƒçš„å·¥ä½œæµæ‰§è¡Œæ•°
- **Tokenä½¿ç”¨ç»Ÿè®¡**: æŒ‰ç§Ÿæˆ·å’Œä¾›åº”å•†çš„Tokenæ¶ˆè€—

### æ—¥å¿—æ ¼å¼

```json
{
  "timestamp": "2025-07-17T14:30:00Z",
  "level": "INFO",
  "service": "eino-service",
  "request_id": "req-uuid",
  "tenant_id": "tenant-uuid",
  "operation": "chat_completion",
  "provider": "openai",
  "model": "gpt-4",
  "execution_time_ms": 1250,
  "tokens_used": 357,
  "success": true,
  "message": "èŠå¤©å®Œæˆ"
}
```

## âš ï¸ é‡è¦çº¦æŸ

### å®‰å…¨è¦æ±‚
1. **APIå¯†é’¥å®‰å…¨**: ä¾›åº”å•†APIå¯†é’¥å¿…é¡»å®‰å…¨å¤„ç†ï¼Œä¸å¾—å‡ºç°åœ¨æ—¥å¿—ä¸­
2. **ç§Ÿæˆ·éš”ç¦»**: ä¸¥æ ¼çš„ç§Ÿæˆ·æ•°æ®éš”ç¦»ï¼Œé˜²æ­¢äº¤å‰è®¿é—®
3. **è¯·æ±‚éªŒè¯**: æ‰€æœ‰APIè¯·æ±‚å¿…é¡»é€šè¿‡JWTéªŒè¯

### æ€§èƒ½è¦æ±‚  
- **å“åº”å»¶è¿Ÿ**: P95 < 2000msï¼ˆæ ‡å‡†èŠå¤©ï¼‰
- **å¹¶å‘å¤„ç†**: æ”¯æŒ100å¹¶å‘è¯·æ±‚
- **ååé‡**: æ¯ç§’å¤„ç†200+è¯·æ±‚

### å¯é æ€§è¦æ±‚
- **æ•…éšœè½¬ç§»**: å‡­è¯å¤±è´¥æ—¶è‡ªåŠ¨åˆ‡æ¢åˆ°å…¶ä»–å¯ç”¨å‡­è¯
- **å¥åº·æ£€æŸ¥**: å®šæœŸæ£€æŸ¥å‡­è¯å¯ç”¨æ€§
- **ä¼˜é›…é™çº§**: æœåŠ¡å¼‚å¸¸æ—¶æä¾›åŸºæœ¬åŠŸèƒ½

## ğŸ¯ å¼€å‘æœ€ä½³å®è·µ

### 1. EINOæ¡†æ¶ä½¿ç”¨åŸåˆ™

- **æŒ‰éœ€å¯¼å…¥**: åªå¯¼å…¥å®é™…éœ€è¦çš„eino-extç»„ä»¶ï¼Œé¿å…å¼•å…¥ä¸å¿…è¦çš„ä¾èµ–
- **ç±»å‹å®‰å…¨ä¼˜å…ˆ**: åˆ©ç”¨EINOçš„ç¼–è¯‘æœŸç±»å‹æ£€æŸ¥ï¼Œåœ¨Compile()é˜¶æ®µå‘ç°é—®é¢˜
- **ç»„ä»¶å¤ç”¨**: å°†åˆ›å»ºå¥½çš„ChatModelç­‰ç»„ä»¶ç¼“å­˜å¤ç”¨ï¼Œé¿å…é‡å¤åˆå§‹åŒ–
- **é”™è¯¯å¤„ç†**: å……åˆ†åˆ©ç”¨Goçš„é”™è¯¯å¤„ç†æœºåˆ¶ï¼Œç¡®ä¿ç¨³å®šæ€§

### 2. æ€§èƒ½ä¼˜åŒ–å»ºè®®

- **ç¼–è¯‘ç¼“å­˜**: é¢„ç¼–è¯‘å¸¸ç”¨çš„Chainå’ŒGraphï¼Œé¿å…è¿è¡Œæ—¶ç¼–è¯‘å¼€é”€
- **è¿æ¥æ± **: ä¸ºHTTPå®¢æˆ·ç«¯é…ç½®åˆé€‚çš„è¿æ¥æ± å‚æ•°
- **æµå¼ä¼˜å…ˆ**: å¯¹äºé•¿æ–‡æœ¬ç”Ÿæˆï¼Œä¼˜å…ˆä½¿ç”¨Streamæ¨¡å¼æå‡ç”¨æˆ·ä½“éªŒ
- **ç›‘æ§é›†æˆ**: é›†æˆEINOçš„å›è°ƒæœºåˆ¶å®ç°å…¨é“¾è·¯è¿½è¸ª

### 3. é”™è¯¯å¤„ç†å’Œé™çº§

```go
// æ™ºèƒ½é™çº§ç¤ºä¾‹
func (w *StandardChatWorkflow) ExecuteWithFallback(ctx context.Context, req *WorkflowRequest) (*WorkflowResponse, error) {
    providers := []string{"openai", "deepseek", "ark"} // æŒ‰ä¼˜å…ˆçº§æ’åº
    
    for _, provider := range providers {
        if credential, err := w.credentialManager.GetBestCredential(req.TenantID, provider); err == nil {
            if result, err := w.executeWithProvider(ctx, req, credential); err == nil {
                return result, nil
            }
            // è®°å½•å¤±è´¥ï¼Œå°è¯•ä¸‹ä¸€ä¸ªä¾›åº”å•†
            w.logger.WithError(err).Warnf("Provider %s failed, trying next", provider)
        }
    }
    
    return nil, fmt.Errorf("æ‰€æœ‰ä¾›åº”å•†éƒ½ä¸å¯ç”¨")
}
```

---

**ğŸ¯ æ€»ç»“**: EINO ServiceåŸºäºå­—èŠ‚è·³åŠ¨å¼€æºçš„EINOæ¡†æ¶ï¼Œä¸“æ³¨äºæä¾›ç±»å‹å®‰å…¨ã€é«˜æ€§èƒ½çš„AIæ¨¡å‹ç¼–æ’æœåŠ¡ã€‚é€šè¿‡æ­£ç¡®ç†è§£EINOçš„æ¶æ„è®¾è®¡å’Œæœ€ä½³å®è·µï¼Œèƒ½å¤Ÿæ„å»ºå‡ºç¨³å®šå¯é ã€æ˜“äºç»´æŠ¤çš„ä¼ä¸šçº§AIåº”ç”¨ã€‚